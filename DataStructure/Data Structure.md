# 数据结构

> https://www.geeksforgeeks.org/
>
> https://www.bilibili.com/video/BV1nJ411V7bd

## 图

### 图的表示方法

#### 邻接矩阵表示法

> [数据结构与算法基础](https://www.bilibili.com/video/BV1nJ411V7bd)
> 
> [AMGraph](./Codes/1_Graph/AMGraph.h)

##### 邻接矩阵的优点

1. 直观、简单、好理解
2. 方便检查任意一对定点间是否存在边
3. 方便找任意顶点的所有“邻接点“（有边直接相连的顶点）
4. 方便计算任一顶点的“度”
	+ 无向图： 对应行（或列）非0元素的个数
	+ 有向图： 对应行非0元素的个数是“出度”；对应列非0元素的个数是“入度”

##### 邻接矩阵的缺点

1. 不便于增加和删除顶点
2. 浪费空间——存稀疏图（点很多而边很少）有大量无效元素
	+ 对稠密图（特别是完全图）还是很合算的
3. 浪费时间——统计稀疏图中一共有多少条边

#### 邻接表的表示方法

[ALGraph](./Codes/1_Graph/AdjList.h)

***邻接表的特点***

1. 方便找任一顶点的所有“邻接点”
2. 节约稀疏图的空间
	+ 需要N个头指针+2E个结点（每个节点至少2个域）
3. 方便计算任一顶点的“度”？
	+ 对无向图：是的
	+ 对有向图：只能计算“出度”；需要构造“逆邻接表”来方便计算“入度”
4. 不方便检查任意一对顶点间是否存在边

#### 十字链表

> 十字链表（*ORthogonal List*）是有向图的另一种链式存储结构。我们也可以把它看成是将有向图的邻接表和逆邻接表结合起来形成的一种链表
>
> 有向图中的每一条弧对应十字链表中的一个弧结点，同时有向图中的每个顶点在十字链表中对应有一个结点，叫做顶点结点

为顶点增加一个入度链表；为弧结点增加数据域，记录弧头位置、弧尾位置、弧头相同的下一条弧、弧尾相同的下一条弧

#### 邻接多重表

> 邻接多重表（*adjacency multilist*）是无向图的另一种链式存储结构。

为边结点添加数据域：

| `mark` | `ivex` | `ilink ` | `jvex` | `jlink` |
|--------|--------|----------|--------|---------|
| 标志域， 标记这条边是否被搜索过 | 该边依附的两个顶点在表头数组中位置 | 指向依附于`ivex`的下一条边 | 该边依附的两个顶点在表头数组中的位置 | 指向依附于`jvex`的下一条边 | 

### 图的遍历

#### 深度优先搜索（***Depth_First_Search***）

> 图的深度有限遍历（或搜索）类似于树的先根遍历。

```cpp
void DFS(AMGraph G, int v)
{
	cout << v; 
	visited[v] = true;
	for (w = 0; w < G.vexnum; w++)
	{
		if ((G.arcs[v][w] != 0) && (!visited[w]))
		{
			DFS(G, w);
		}
	}
}
```

******

***算法效率分析***

+ 用**邻接矩阵**来表示图，遍历图中每一个顶点都要**从头扫描**该顶点所在行，时间复杂度为`O(n^2)`
+ 用**邻接表**来表示图，虽然有`2e`个表结点，但只需要扫描`e`个结点即可完成遍历，加上访问`n`个头结点的时间，时间复杂度为`O(n+e)`

***结论***

+ **稠密图**适于在邻接矩阵上进行深度测试
+ **稀疏图**适于在邻接表上进行深度遍历

#### 广度优先搜索（***Breadth_First_Search***）

> 图的广度优先遍历（或搜索）类似于树的广度优先遍历。这里唯一需要注意的是，与树不同，图可能包含循环，因此我们可能再次来到同一个节点。为了避免多次处理节点，我们使用布尔数组。为简单起见，假设所有顶点都可以从起始顶点到达。

[非递归方法](./Codes/1_Graph/BFS.cpp)

```cpp
void BFS(Graph G, int v)
{
	cout << v;				// 访问第v个顶点
	visited[v] = true;	
	InitQueue(Q);			// 辅助队列Q初始化，置空
	EnQueue(Q, v);			// v进队
	while (!QueueEmpty(Q))	// 队列非空
	{
		DeQueue(Q, u);		// 队头元素出队并置为u
		for (w = FirstAdjVex(G, u); w >= 0; w = NextAjdVex(G, u, w))
		{
			if (!visited[w])	// w为u的尚未访问的邻接顶点
			{
				cout << w;
				visited[2] = true;
				EnQueue(Q, w);	// w进队
			}
		}
	}
}
```

***BFS算法效率分析***
+ 如果使用临街矩阵，则BFS对于每一个被访问到的顶点，都要循环检测矩阵中的整整一行（n个元素），总的时间代价为`O(n^2)`
+ 用邻接表来表示图，虽然有`2e`个表结点，但只需要扫描`e`个结点即可完成遍历，加上访问n个头节点的时间，时间复杂度为`O(n+e)`

#### DFS与BFS算法效率比较

+ 空间复杂度相同，都是`O(n)`（借用了堆栈或队列）
+ 时间复杂度只与存储结构（邻接矩阵或邻接表）有关，而与搜索路径无关

### 图的应用

#### 最小生成树

> 生成树：所有顶点均由边连接在一起，但**不存在回路**的图
>
> 1. 一个图可以有许多不同的生成树
> 2. 所有生成树具有以下共同特点：
>		+ 生成树的顶点个数与图的**顶点个数相同**
>		+ 生成树是图的**极小连通子图**，去掉一条边则非连通
>		+ 一个有n个顶点的连通图的生成树有`n - 1`条边
>		+ **在生成树中再加一条边必然形成回路**
>		+ 生成树中任意两个顶点间的**路径是唯一的**
> 3. 含n个顶点`n - 1`条边的图不一定是生成树

******

- 深度优先生成树
- 广度优先生成树

******

***最小生成树： ***给定一个无向网络，在该网的所有生成树中，使得**各边权值之和最小**的那颗生成树称为该网的***最小生成树***，也叫**最小代价生成树**

##### 构造最小生成树（Minimum Spanning Tree）

***MST性质：***设`N = (V, E)`是一个连通网，U是顶点集V的一个非空子集。若边`(u, v)`是一条具有最小权值的边，其中`u ∈ U`，`v ∈ V - U`，则比存在一棵包含边`(u, v)`的最小生成树

其中，U是已经落在生成树上的顶点集，`V - U`是尚未落在生成树上的顶点集

###### 普里姆（*Prim*）算法

***算法思想：***

1. 设`N = (V, E)`是连通网，`TE`是N上最小生成树中**边的集合**
2. 初始令`U = {u0}, (u0 ∈ V)`, `TE = {}`
3. 在所有`u ∈ U`，`v ∈ V - U`的边`(u, v)`中，找一条代价最小的边`(u0, v0)`
4. 将`(u0, v0)`并入集合`TE`，同时`v0`并入`U`
5. 重复上述操作，直到`U == V` 为止，则`T = (V, TE)`为`N`的最小生成树

###### 克鲁斯卡尔（*Kruskal*）算法

> 贪心算法

1. 设连通网`N = (V, E)`，令最小生成树初始状态**只有**n个**顶点**而**无边**的非连通图`T = (V, {})`，每个顶点自称一个连通分量
2. 在`E`中选取代价最小的边，若该边衣服的顶点落在T中不同的连通分量上（即：**不能形成环**），则将此边加入到`T`中；否则，舍去此边，选取下一条代价最小的边
3. 以此类推，直至`T`中所有顶点都在同一连通分量上为止

###### 两种算法的比较

| 算法名称 | 算法思想 | 时间复杂度 | 适应范围 |
|--|--|--|--|
|普里姆算法|选择点|`O(n^2)`（n为顶点数）|稠密图|
|克鲁斯卡尔算法|选择边|`O(e * log(e))`（e为边数）|稀疏图|

#### 最短路径

##### Dijskra算法

##### Floyd算法

#### 拓扑排序与关键路径

##### 拓扑排序——***AOV(Active on Vertext)***网的应用

> 将一个有向无环图转换成有原本的顺序的一个序列，或者用于判断一个有向图是否有环

有向无环图的定义：一个点可以有多个前驱，也可以有多个后继，但是不能有一条回路

***算法核心思想：***
1.	选择一个没有前驱的点打印，并删除这个点和这个点上的弧
2.	重复1直到没有点或者没有没有前驱的点

如果结束后还有点没有删除，那么就说明这个图不是有向无环图

##### 关键路径——***AOE(Active on Edge)***网的应用

> 用于确定在一项工程中，最为关键的事件集、或者是某些事件开始的最早、最晚时间。

对于AOE网，我们关系两个问题：
1.	完成正线工程需要多少时间？
2.	哪些活动是影响工程进度的关键？

引出两个概念：
1.	关键路径：路径长度最长的路径
2.	路径长度：路径上个活动持续时间之和

***如何确定关键路径，需要定义4个描述量（v为事件开始和结束的节点，a为事件所需要的时间弧）：***
1.	$v_{e}(v_{j})$：表示事件$v_{j}$的最早发生时间
	计算方式：从整个项目的第一个节点开始计算
2.	$v_{l}(v_{j})$：表示事件$$v_{j}的最迟发生时间
	计算方式：从整个项目的结束节点反向计算
3.	$e_{i}$：表示活动$a_{i}$的最早开始时间
	计算方式同1
4.	$l_{i}$：表示活动$a_{i}$的最迟开始时间
	计算方式同2

时间余量：在不影响整个项目完成的前提下，一个任务的最晚开始时间与最早开始时间的差，即$l(i)-e(i)$

**关键活动**：关键路径上的活动，即$l(i) == e(i)$的活动

******

***如何找$l(i) == e(i)$的关键活动？***

设活动$a_{i}$用弧$<j, k>$表示，其持续时间记为$W_{j,k}$，则有：

1.	$e(i) = v_{e}(j)$

2.	$l(i) = v_{l}(k) - W_{j,k}$

***如何求$v_{e}(j)$和$v_{l}(j)$？***

> 求$v_e(v_j)$，由源点至汇点
>
> 求$v_l(v_j)$，由汇点至源点

1.	从$v_{e}(1) = 0$开始向前递推
	$$	v_{e}(j) = Max\{v_{e}(i) + W_{i,j}\}, \\<i,j>\in T, \\2 \le j \le n	$$
	其中， `T`是所有以`j`开头的弧的集合

	这个公式的含义是，计算该节点之前的所有路径需要花费的最长时间。原因是，需要等当前任务之前所有的必须任务全部完成，这个任务才能开始。
2.	从$v_{l}(n) = v_{e}(n)$开始向后递推
	$$ v_{l}(i) = Min\{v_{l}(j) - W_{i,j}\}, \\ <i,j>\in T, \\ 1 \le i \le n-1 $$
	其中，`S`是所有以`i`结尾的弧的集合
	这个公式的含义是，计算该节点之前的所有任务所花费的时间并减去，从而得到任务开始的时间，并在这些开始时间中选择最小的那一个，因为只有在这个时间开始，耗时最长的任务才能完成。

***求关键路径步骤***
1.	求$v_e(i)$、$v_l(j)$
2.	求$e(i)$、$l(i)$
3.	计算$l(i)-e(i)$，并找其中等于0的项


## 查找

### 查找的基本概念

***在哪里找？***

**查找表**是由同一类型的数据元素（或记录）构成的集合。由于“集合“中的数据元素之间存在着松散的关系，因此查找表是一种应用灵便的结构。

***什么查找？***

> 根据给定的值，在查找表中确定一个其关键字等于给定值的数据元素或记录

*	关键字：用来标识一个数据元素或记录的某个数据项的值
	*	主关键字：可唯一地标识一个记录的关键字是主关键字
	*	次关键字：反之，用以识别若干记录的关键字是次关键字

***查找是否成功？***

*	或查找表中存在这样一个记录，则称“查找成功”
	*	查找结果给出整个记录的信息，或指示该记录在查找表中的位置
*	否则称“查找不成功”
	*	查找结果给出“空记录”或“空指针”

***查找的目的***

1.	查询某个“特定的”数据元素是否在查找表中
2.	检索某个“特定的”数据元素的各种属性
3.	在查找表中插入一个数据元素
4.	删除查找表中的某个数据元素

***查找表怎么分类？***

查找表可分为两类：

1.	静态查找表

	仅做“查找”（检索）操作的查找表

2.	动态查找表

	作“插入”和“删除”操作的查找表

	有时在查询之后，还需要将”查询“结果为”不在查找表中“的元素插入到查找表中；或者，从查表中删除其“查询”结果为“在查找表中”的数据元素

***如何评价查找算法？***

查找算法的评价指标：

关键字的平均比较次数，也称***平均查找长度ASL(Average Search Length)***

$$
ASL = \sum_{i = 1}^{n} p_i c_i \\
n: 记录的个数 \\
p_i: 查找第i个记录的概率（通常认为p_i = \frac{1}{n}） \\
c_i: 找到第i个记录所需的比较次数
$$

***问题：查找过程中要研究什么？***

	查找的方法取决于查找表的结构，即表中数据元素是依何种关系组织在一起的。
	
	由于对查找表来说，在集合中查询或检索一个“特定的”数据元素时，若无规律可循，只能对集合中的元素一一加一辨认直至找到为止。
	
	而这样的“查询”或“检索”是任何计算机应用系统中使用频度很高的操作，因此设法提高查找表的寻找效率，是本章讨论问题的出发点。
	
	为提高查找效率，一个办法就是在构造查找表时，在集合中的数据元素之间人为地加上某种确定的约束关系。

### 线性表的查找

#### 分块查找

##### 条件

1.	将表分成几块，且表或者有序，或者**分块有序**

	若i < j，则第j块中所有记录的关键字均大于第i块中的最大关键字

2.	建立“索引表”（每个节点含有最大关键字域和指向本块第一个结点的指针，且按关键字有序）

##### 查找过程

先确定查找记录所在块（顺序或对半查找），再在块内查找（顺序查找）

##### 分块查找性能分析

$$
ASL=L_b + L_w \\
L_b: 对索引表查找的ASL \\
L_w: 对块内查找的ASL \\
ASL_{block\thinspace search} \approx log_2(\frac{n}{s} + 1) + \frac{s}{2} \qquad (log_2n < ASL_bs \le \frac{n+1}{2}) \\
s为每块内部的记录个数，\frac {n}{s}即块的数目
$$

##### 查找方法比较

| | 顺序查找 | 二分查找 | 分块查找|
|--|--|--|--|
| ASL | 最大 | 最小| 中间 |
| ASL | $\frac{n + 1}{2}$ | $log_2(\frac{n}{s} + 1) + \frac{s}{2}$ | $log_2(n+1)$ |
| 表结构 | 有序表、无序表 | 有序表 | 分块有序 |
| 存储结构 | 顺序表、线性链表 | 顺序表 | 顺序表、线性链表 |
| 时间复杂度 | $O(n)$ | $O(log_2n)$ | $O(log_2n) \sim O(n)$
