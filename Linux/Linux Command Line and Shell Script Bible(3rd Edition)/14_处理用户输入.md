# 命令行参数

向shell脚本传递数据的最基本方法是使用命令行参数。命令行参数允许在脚本运行时向命令行添加参数。

## 读取参数

bash shell会将一些称为位置参数（positional parameter）的特殊变量分配给输入到命令行中的所有参数。这也包括shell所执行的脚本的额名称。位置参数变量是标准的数字：`$0`是程序名，`$1`是第一个参数，依此类推，直到第九个参数。如果脚本需要的命令行参数不只9个，我们仍然可以处理，但是需要稍微修改一些变量名。在第九个变量之后，我们必须在变量数字周围加上花括号，比如`${10}`

如果参数中包含空格，那么就需要用引号包围，同时在处理的时候，参数中不会包含引号

## 读取脚本名和`basename`

可以用`$0`参数获取shell在命令行中启动的脚本名。这在编写多功能工具时非常方便。

但是存在一个潜在的问题。如果我们使用另一个命令来运行shell脚本，命令回合脚本名混在一起，出现在`$0`参数中。

```shell
./test5.sh
The zero parameter is set to: ./test5.sh
```

这还不是唯一的问题。当我们使用绝对路径调用脚本的时候，`$0`就会使用整个路径：

```shell
bash /home/Christine/test5.sh
The zero paramter is set to: /home/Christine/test5.sh
```

不过我们可以使用`basename`来返回不包含路径的脚本名：

```shell
$(basename $0)
```

## 测试参数

在使用参数前一定要检查其中是否存在数据：

```shell
if [ -n "$1" ]
then
	...
else
	...
fi
```

# 特殊参数变量

## 参数统计——`$#`

特殊变量`$#`含有脚本运行时鞋带的命令行参数的个数。

需要注意的是，如果我们想要使用`$#`直接获得最后一个参数，是不可以的：

```shell
${$#}
```

我们需要使用`!`：

```shell
${!#}
```

## 抓取所有的数据——`$*` & `$@`

如果我们想要遍历命令行上提供的所有参数，我们不需要先使用`$#`来判断命令行上有多少参数，然后再进行遍历，我们可以使用一组其他的变量来解决这个问题：

+ `$*`会将命令行上提供的所有参数当做一个单词保存。这个单词包含了命令行中出现的每一个参数值。***基本上`$*`会将这些参数是为一个整体，而不是多个个体。***
+ `$@`会将命令行上提供的所有参数当做同一字符串中的多个独立的单词。***这样我们就能够遍历所有的参数值，得到每一个参数***

# 移动变量——`shift`

bash shell的`shift`命令用来操作命令行参数。和字面上的意思一样，`shift`命令会根据它们的相对位置来移动命令行参数。

在使用`shift`命令时，默认情况下它会将每个参数变量向左移动一个位置。所以，变量`$3`中的值会移到`$2`中，变量`$2`的值会移到`$1`中，而变量`$1`的值则会被删除。（注意，变量`$0`的值，也就是程序名，不会更改）。

这是遍历命令行参数的另一个好办法，尤其是在我们不知道到底有多少参数时。我们可以只操作第一个参数，移动参数，然后继续操作第一个参数

```shell
while [ -n "$1" ]
do
	...
	shift
done
```

> 使用`shift`命令的时候要小心。如果某个参数被移除，它的值就被丢弃了，无法再回复。

当然，我们也可以一次性移动多个位置，只需要给`shift`命令提供一个参数，指明要移动的位置数就行了。

```shell
#! /bin/bash
# demonstrating a multi-position shift
#
echo
echo "The original parameters: $*"
shift 2
echo "Here the new first parameter: $1"
```

<img src="14_处理用户输入.assets/image-20220928190120007.png" alt="image-20220928190120007" style="zoom:50%;" />

# 处理选项

## 查找选项

### 1. 处理简单选项

当我们在脚本中使用命令选项这样的操作方式：

```shell
./test15.sh -a -b -d -f
```

我们只需要使用`shift`和`case`就好了：

```shell
while [ -n "$1" ]
do
	case "$1" in
		-a) ... ;;
		-b) ... ;;
		-c) ... ;;
		*)  ... ;;
	esac
	shift
done
```

这样，无论选项按照什么样的顺序出现在命令行上，这种方式都适用。

### 2. 分离参数和选项

我们经常会遇到想在shell脚本中同时使用选项和参数的情况。Linux中处理这个问题的标准方式使用特殊字符来将二者分开，该字符会告诉脚本何时选项结束以及普通参数何时开始

对Linux来说，这个特殊字符是双破折线（`--`）。在双破折线之后，脚本就可以放心地将剩下的命令行参数当做参数，而不是选项来处理了。

```shell
#! /bin/bash
# extracting options and parameters
#
echo
while [ -n "$1" ]
do
	case "$1" in
		-a) echo "Found the -a option" ;;
		-b) echo "Found the -b option" ;;
		-c) echo "Found the -c option" ;;
		--) shift
			break ;;
		*)	echo "$1 is not an option" ;;
	esac
	shift
done

count=1
for param in $@
do
	echo "Parameter #$count: $param"
	count=$[ $count + 1 ]
done
```

<img src="14_处理用户输入.assets/image-20220928192603107.png" alt="image-20220928192603107" style="zoom:50%;" />

上面这个脚本所做的事是，先读入选项。然后在双横线之后的参数被视为普通的参数，进入接下来的处理部分

### 3. 处理带值的选项

有些选项会带上一个额外的参数值，在这种情况下，命令行看起来是这样的：

```shell
./testing.sh -a test1 -b -c -d test2
```

当当命令行要求额外的参数时，脚本必须能检测到并正确处理。下面是如何处理的例子：

```shell
#! /bin/bash
# extracting options and parameters
#
echo
while [ -n "$1" ]
do
	case "$1" in
		-a) echo "Found the -a option" ;;
		-b) param="$2"
			echo "Found the -b option, with parameter value $param"
			shift ;;
		-c) echo "Found the -c option" ;;
		--) shift
			break ;;
		*)	echo "$1" is not an option ;;
	esac
	shift
done
#
count=1
for param in "$@"
do
	echo "Parameter #$count: $param"
	count=$[ $count + 1 ]
done
```

<img src="14_处理用户输入.assets/image-20220928195437308.png" alt="image-20220928195437308" style="zoom:50%;" />

## 使用`getopt`命令

现在shell脚本已经有了处理命令行选项的基本能力，但还有一些限制。比如，如果我们想将多个选项放进一个参数中时，他就不能工作了：

```shell
./test.sh -ac
```

`getopt`命令是一个在处理命令行选项和参数时特别方便的工具。它能够识别命令行参数，从而在脚本解析它们时更加方便。

### 1. 命令的格式

`getopt`命令可以接受一系列任意形式的命令行选项和参数，并自动将它们转换成适当的格式：

```shell
getopt optstring parameters
```

`optstring`是这个过程的关键所在。它定义了命令行有效的选项字母，还定义了哪些选项字母需要参数值。

首先，在`optstring`中列出我们要在脚本中用到的每个命令行选项字母。然后，在每个需要参数值的选项字母后加一个冒号。`getopt`命令会给予我们定义的`optstring`解析提供的参数。

下面是一个简单的例子：

```shell
getopt ab:cd -a -b test1 -cd test2 test3
```

<img src="14_处理用户输入.assets/image-20220928202151997.png" alt="image-20220928202151997" style="zoom:50%;" />

`optstring`定义了四个有效选项字母：a、b、c和d。冒号(`:`)被放在了字母b后面，因为b选项需要一个参数值。当`getopt`命令运行时，它会检查提供的参数列表，并给予提供的`optstring`进行解析。注意，它会将`-cd`分成两个单独的选项，并插入两个双破折线来分隔行中的额外参数。

如果制定了一个不在`optstring`中的选项，默认情况下，`getopt`会产生一条错误信息。如果想要忽略这条错误信息，可以在命令后添加`-g`选项。

<img src="14_处理用户输入.assets/image-20220928202228393.png" alt="image-20220928202228393" style="zoom:50%;" />

### 2. 在脚本中使用`getopt`

可以在脚本中使用`getopt`来格式化脚本所携带的任何命令行选项或参数，但用起来略微复杂。

方法是使用`getopt`生成的格式化后的版本来替换已有的命令行选项和参数。用`set`命令能够做到。

