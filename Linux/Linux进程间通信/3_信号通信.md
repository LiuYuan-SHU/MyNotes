```mermaid
flowchart LR;
kill_command[kill]
program[test]
subgraph kernel
	
end

kill_command --signal/pid--> kernel --signal--> program
```

# 信号的发送

+ 所需要的头文件：
	+ `#include <signal.h>`
	+ `#include <sys/types.h>`
+ 函数原型
	```c
	/*
	 * pid	正数：要接受信号的进程的进程号
	 *		0：信号被发送到所有和pid进程在同一个进程组的进程
	 *		-1：信号发给所有的进程表中的进程（除了进程号最大的进程外）
	 * sig：信号
	 */
	// 函数返回值：成功返回0，失败返回-1
	int kill(pid_t pid, int sig);
	```

[***`mykill.c`***](./code/signal/mykill.c)

# 信号的接收

## `raise(sig)`

> 相当于`kill(getpid(), sig)`

```mermaid
flowchart LR;

program --raise/signal--> kernel --signal--> program
```

[***`raise.c`——杀死自己***](./code/signal/raise.c)

[***`raise_2.c`***](./code/signal/raise_2.c)

在这个例子中，一开始父进程处于休眠状态，子进程处于暂停状态。因此父进程的状态码是S，而子进程的状态码是T；当父进程发送了一个信号给子进程后，父进程开始死循环，子进程被终止但是资源没有被回收，因此父进程处于R状态，子进程成为僵尸状态，即为Z状态。

而如果我们在父进程进入死循环前，让父进程先运行`wait()`函数，那么父进程就会回收资源，然后再开始死循环。

# 信号的处理
