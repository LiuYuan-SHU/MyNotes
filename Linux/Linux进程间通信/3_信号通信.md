[TOC]

# 信号的发送

## `kill`

```mermaid
flowchart LR;
kill_command[kill]
program[test]
subgraph kernel
	
end

kill_command --signal/pid--> kernel --signal--> program
```

+ 所需要的头文件：
	+ `#include <signal.h>`
	+ `#include <sys/types.h>`
+ 函数原型
	```c
	/*
	 * pid	正数：要接受信号的进程的进程号
	 *		0：信号被发送到所有和pid进程在同一个进程组的进程
	 *		-1：信号发给所有的进程表中的进程（除了进程号最大的进程外）
	 * sig：信号
	 */
	// 函数返回值：成功返回0，失败返回-1
	int kill(pid_t pid, int sig);
	```

[***`mykill.c`***](./code/signal/mykill.c)

## `raise(sig)`

> 相当于`kill(getpid(), sig)`

```mermaid
flowchart LR;

program --raise/signal--> kernel --signal--> program
```

[***`raise.c`——杀死自己***](./code/signal/raise.c)

[***`raise_2.c`***](./code/signal/raise_2.c)

在这个例子中，一开始父进程处于休眠状态，子进程处于暂停状态。因此父进程的状态码是S，而子进程的状态码是T；当父进程发送了一个信号给子进程后，父进程开始死循环，子进程被终止但是资源没有被回收，因此父进程处于R状态，子进程成为僵尸状态，即为Z状态。

而如果我们在父进程进入死循环前，让父进程先运行`wait()`函数，那么父进程就会回收资源，然后再开始死循环。

## `alarm`

> 只会发送一种信号——`SIGALRM`
>
> 当我们调用`alarm`函数的时候，内核会等待一段时间，这个时间是我们设置的定时，时间到后**只能向当前进程**发送SIGALRM信号
>
> 进程收到这个信号后的默认操作是终止进程

### 函数形式

```c
#include <unistd.h>

/*
 * seconds	指定描述
 */
// 成功：如果调用此alarm前，进程中已经设置了闹钟时间，则返回上一个闹钟时间的剩余时间；
//		否则返回0
// 失败：返回-1
unsigned int alarm(unsigned int seconds);
```

[***`alarm.c`***](./code/signal/alarm.c)

# 信号的接收

## `pause`

> 使进程进入睡眠状态。与`sleep`不同，使用`pause`进入睡眠状态的进程如果不被唤醒，状态就会变为S，然后一直睡眠下去

```c
#include <unistd.h>

// 永远返回-1
int pause(void);
```

[***pause.c***](./code/signal/pause.c)

# 信号的处理 —— `signal`

## 函数形式

```c
#include <signal.h>

/* 
 * sig	制定信号
 * func	SIG_IGN：忽略该信号
 *		SIG_DFL：采用系统默认方式处理信号
 *		自定义的信号处理函数指针
 */
// 成功：设置之前的信号处理方式
// 失败：-1
void (*signal(int sig， void (*func)(int)))(int);
```

## 分析

+ A = `void (*func)(int)`
	函数指针变量，函数的形式：含有一个整型参数，返回值是`void`
+ `void (*signal(int sig, A))(int)`
	`signal`是一个函数，接受一个整数和一个形如A的函数指针

	它的返回值是一个函数指针，这个函数指针的参数是一个整数，返回值是`void`

	当接收到对应的信号的时候，就会调用这个处理函数，并将这个信号的值传给处理函数

## 作用

`signal`函数告诉内核两个内容：

+ 处理哪个信号
+ 如何处理
	+ SIG_IGN：就像没有接收到信号
	+ SIG_DFL：采用系统默认方式处理信号
	+ 自定义的信号处理函数指针：在接受到信号后，先进入定义的处理函数，再回到程序正在运行的位置
		```mermaid
		flowchart LR
		subgraph kernel
		
		end
		subgraph pb[program B]
			running[正在进行的部分]
			自定义的信号处理函数指针
		end
		
		kernel --signal--> pb	
		running --接到信号--> 自定义的信号处理函数指针 --处理结束--> running
		```

## 举个栗子

### 自定义的信号处理函数指针

[***`signal.c`***](./code/signal/signal.c)

运行结果：

```
alarm before
alarm after
process things, i = 1
process things, i = 2
process things, i = 3
process things, i = 4
process things, i = 5
process things, i = 6
process things, i = 7
process things, i = 8		// 程序在这个地方接收到信号，进入信号处理函数
process signal signum=0
process signal signum=1
process signal signum=2
process signal signum=3
process signal signum=4
process signal signum=5
process signal signum=6
process signal signum=7
process signal signum=8
process signal signum=9		// 信号处理函数结束，返回正在运行的地方
process things, i = 9
process things, i = 10
```

### SIG_IGN

[***`signal_SIGIGN.c`***](./code/signal/signal_SIGIGN.c)

### SIG_DFT

[***`signal_SIGDFL.c`***](./code/signal/signal_SIGDFL.c)

## 发送信号

我们可以使用10号信号：SIGUSR1

又或者，当子进程结束的时候，会发信号SIGCHLD给父进程，我们可以利用这点写一个处理函数。

```c
void recycle(int signum)
{
	printf("receie signum = %d\n", signum);
	wait(NULL);		// 接收到信号，然后做资源回收

	return;
}
```
