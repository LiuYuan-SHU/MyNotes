```toc
```
# 12.1 动态内存与智能指针

为了更容易（同时也更安全）地使用动态内存，新的标准库提供了两种**智能指针（smart pointer）**类型来管理动态对象。智能指针的行为类似常规指针，重要的区别是它负责自动释放所指向的对象。新标准库提供的这两种智能指针的区别在于管理底层指针的方式：
* `shared ptr`允许多个指针指向同一个对象
* `unique_ptr`则“独占”所指向的对象

标准库还定义了一种名为`weak_ptr`的伴随类，它是一种弱引用，指向`shared_ptr`所管理的对象。==这三个类型都定义在`memory`头文件中==

## 12.1.1 `shared_ptr`

类似于`vector`，智能指针也是模板。

```cpp
shared_ptr<string> p1;
share_ptr<list<int> > p2;
```

### `make_shared`

> `make_shared<T>(args)`

最安全的分配和使用动态内存的方法是调用一个名为`make_shared`的标准库函数。此函数在动态内存中分配一个对象并初始化它，返回指向此对象的`shared_pre`。

### `shared_ptr`的拷贝和赋值

每个`shared_ptr`都会记录有多少个其他`shared_ptr`指向相同的对象。我们可以认为每个`shared_ptr`都有一个关联的计数器，通常称其为**引用计数（reference count）**。
一旦一个`shred_ptr`的计数器变为0，它就会自动释放自己所管理的对象。

### `shared_ptr`自动销毁所管理的对象

销毁的时候，`shared_pre`就会调用其所包含对象的析构函数。

### 使用了动态生存期的资源的类

程序使用动态内存出于以下三种原因之一：
1. 程序不知道自己需要使用多少对象
2. 程序不知道所需对象的准确类型
3. 程序需要知道在多个对象间共享数据

## 12.1.2 直接管理内存

默认情况下，动态分配的对象是默认初始化的，这意味着**内置类型或组合类型的对象的值将是未定义的，而类类型对象将用默认函数进行初始化**。对于内置类型，通常我们可以使用值初始化的方法：`int *p = new int()`。

### 内存耗尽

虽然现代计算机通常都配备大容量内存，但是自由空间被耗尽的情况还是有可能发生。一旦一个程序用光了它所有可用的内存，`new`就会失败。默认情况下，如果`new`不能分配所要求的内存空间，抛出异常`bad_alloc`。我们可以改变使用`new`的方式来阻止其抛出异常。
```cpp
int *p1 = new int;           // 如果分配失败，new抛出std::bad_alloc
int *p2 = new (nothrow) int; // 如果分配失败，返回空指针
```

我们称这种形式的`new`为**定位`new`**。定位`new`允许我们向`new`传递额外的参数。

### 释放动态内存——`delete`

与`new`类型类似，`delete`表达式也执行两个动作：销毁给定的指针指向的对象；释放对应的内存。

### 指针值和`delete`

> [!Warning] 警告
> 释放一块并非`new`分配的内存，或者将相同的指针值释放多次，其行为是未定义的。

## 动态对象的生存期直到被释放为止

> [!Warning] 警告
> 使用`new`和`delete`管理动态内存存在三个常见问题：
> 1. 忘记`delete`内存。忘记释放动态内存会导致人们常说的“内存泄漏”问题，因为这种内存永远不可能被归还给自由空间了。查找内存泄漏错误是非常困难的，因为通常应用程序运行很长时间后，真正耗尽内存时，才能检测到这种错误。
> 2. 使用已经释放掉的对象。通过在释放内存后将指针置为空，有时可以检测出这种错误。
> 3. 同一块内存释放两次。当有两个指针指向相同的动态分配对象时，可能发生这种错误。如果对其中一个指针进行了`delete`操作，对象的内存就被归还给自由空间了。如果我们随后又`delete`第二个指针，自由空间就可能被破坏。

# 12.1.3 `shared_ptr`和`new`结合使用

我们可以使用`new`返回的指针来初始化智能指针，但是需要注意的是，用于构造智能指针的构造函数是`explicit`的。也就是说，不能使用隐式转换的内嵌指针构造智能指针。

```cpp
shared_ptr<double> p1(new double(3.14)); // 正确
shared_ptr<int> p2 = new int(10);        // 错误

```

默认情况下，一个用来初始化智能指针的普通指针必须指向动态内存，因为智能指针默认使用`delete`释放它所关联的对象。我们可以将只能指针绑定到一个指向其他类型的资源的指针上，但是为了这样做，必须提供自己的操作来替代`delete`。

| 代码                    | 解释                                                                                                        |
| ------------------------------ | ----------------------------------------------------------------------------------------------------------- |
| `shared_ptr<T> p(q)`    | `p`管理内置指针`q`所指向的对象；`q`必须指向`new`分配的内存，同时能够转换为`T*`类型                          |
| `shared_ptr<T> p(u)`    | `p`从`unique_ptr` `u`哪里接管了对象的所有权；将`u`置为空                                                    |
| `shared_ptr<T> p(q, d)` | `p`接管了内置指针`q`所指向的对象的所有权。`q`必须能转换为`T*`类型。`p`将使用**可调用对象**`d`来代替`delete` |
| `p.reset()`  </br> `p.reset(q)` </br> `p.reset(q.d)`                      |  若`p`是唯一指向其对象的`shared_ptr`，`reset`会释放此对象。若传递了可选参数`q`，会令`p`指向`q`，否则会将`p`置为空。若还传递了参数`d`，那么就会使用`d`而不是`delete`来释放`q`                                                                                                           |

### 不要混合使用普通指针和智能指针

考虑下面的代码：

```C++
// 设已有函数：
void process(shared_pre<int> ptr);

int *x(new int(1024));  // 危险：x是一个普通指针，不是一个智能指针
process(x);             // 错误：不能使用隐式转换
process(shared_ptr<int>(x)); // 正确但是指针会被释放！
// 行为未定义
int i = *x;
```

在上面的调用中，我们将一个临时`shared_ptr`传递给`process`。当这个调用所在的表达式结束的时候，这个临时对象会被销毁。销毁这个临时变量会递减引用计数，此时引用计数将变为**0**。因此，**当临时对象被销毁时，它所指向的内存会被释放**。

因此，当`i`尝试解引用`x`的时候，其在试图访问一个已经被释放的动态内存。


> [!Tips] 提示
> 当我们使用一个`shared_ptr`绑定到一个普通指针的时候，我们就将内存管理的责任交给了智能指针。一旦这样做，**我们就不应该在使用内置指针来访问智能指针所维护的内存**。

### 不要使用`get`初始化另一个智能指针或为智能指针赋值

> 