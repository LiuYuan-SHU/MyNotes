```toc
```
# 12.1 动态内存与智能指针

为了更容易（同时也更安全）地使用动态内存，新的标准库提供了两种**智能指针（smart pointer）**类型来管理动态对象。智能指针的行为类似常规指针，重要的区别是它负责自动释放所指向的对象。新标准库提供的这两种智能指针的区别在于管理底层指针的方式：
* `shared ptr`允许多个指针指向同一个对象
* `unique_ptr`则“独占”所指向的对象

标准库还定义了一种名为`weak_ptr`的伴随类，它是一种弱引用，指向`shared_ptr`所管理的对象。==这三个类型都定义在`memory`头文件中==

## 12.1.1 `shared_ptr`

类似于`vector`，智能指针也是模板。

```cpp
shared_ptr<string> p1;
share_ptr<list<int> > p2;
```

### `make_shared`

> `make_shared<T>(args)`

最安全的分配和使用动态内存的方法是调用一个名为`make_shared`的标准库函数。此函数在动态内存中分配一个对象并初始化它，返回指向此对象的`shared_pre`。

### `shared_ptr`的拷贝和赋值

每个`shared_ptr`都会记录有多少个其他`shared_ptr`指向相同的对象。我们可以认为每个`shared_ptr`都有一个关联的计数器，通常称其为**引用计数（reference count）**。

给一个`shared_ptr`赋值也会导致其引用计数递减。

一旦一个`shred_ptr`的计数器变为0，它就会自动释放自己所管理的对象。

### `shared_ptr`自动销毁所管理的对象

销毁的时候，`shared_pre`就会调用其所包含对象的析构函数。

### 使用了动态生存期的资源的类

程序使用动态内存出于以下三种原因之一：
1. 程序不知道自己需要使用多少对象
2. 程序不知道所需对象的准确类型
3. 程序需要知道在多个对象间共享数据

## 12.1.2 直接管理内存

默认情况下，动态分配的对象是默认初始化的，这意味着**内置类型或组合类型的对象的值将是未定义的，而类类型对象将用默认函数进行初始化**。对于内置类型，通常我们可以使用值初始化的方法：`int *p = new int()`。

### 内存耗尽

虽然现代计算机通常都配备大容量内存，但是自由空间被耗尽的情况还是有可能发生。一旦一个程序用光了它所有可用的内存，`new`就会失败。默认情况下，如果`new`不能分配所要求的内存空间，抛出异常`bad_alloc`。我们可以改变使用`new`的方式来阻止其抛出异常。
```cpp
int *p1 = new int;           // 如果分配失败，new抛出std::bad_alloc
int *p2 = new (nothrow) int; // 如果分配失败，返回空指针
```

我们称这种形式的`new`为**定位`new`**。定位`new`允许我们向`new`传递额外的参数。

### 释放动态内存——`delete`

与`new`类型类似，`delete`表达式也执行两个动作：销毁给定的指针指向的对象；释放对应的内存。

### 指针值和`delete`

> [!Warning] 警告
> 释放一块并非`new`分配的内存，或者将相同的指针值释放多次，其行为是未定义的。

### 动态对象的生存期直到被释放为止

> [!Warning] 警告
> 使用`new`和`delete`管理动态内存存在三个常见问题：
> 1. 忘记`delete`内存。忘记释放动态内存会导致人们常说的“内存泄漏”问题，因为这种内存永远不可能被归还给自由空间了。查找内存泄漏错误是非常困难的，因为通常应用程序运行很长时间后，真正耗尽内存时，才能检测到这种错误。
> 2. 使用已经释放掉的对象。通过在释放内存后将指针置为空，有时可以检测出这种错误。
> 3. 同一块内存释放两次。当有两个指针指向相同的动态分配对象时，可能发生这种错误。如果对其中一个指针进行了`delete`操作，对象的内存就被归还给自由空间了。如果我们随后又`delete`第二个指针，自由空间就可能被破坏。

## 12.1.3 `shared_ptr`和`new`结合使用

我们可以使用`new`返回的指针来初始化智能指针，但是需要注意的是，用于构造智能指针的构造函数是`explicit`的。也就是说，不能使用隐式转换的内嵌指针构造智能指针。

```cpp
shared_ptr<double> p1(new double(3.14)); // 正确
shared_ptr<int> p2 = new int(10);        // 错误

```

默认情况下，一个用来初始化智能指针的普通指针必须指向动态内存，因为智能指针默认使用`delete`释放它所关联的对象。我们可以将只能指针绑定到一个指向其他类型的资源的指针上，但是为了这样做，必须提供自己的操作来替代`delete`。

| 代码                    | 解释                                                                                                        |
| ------------------------------ | ----------------------------------------------------------------------------------------------------------- |
| `shared_ptr<T> p(q)`    | `p`管理内置指针`q`所指向的对象；</br>`q`必须指向`new`分配的内存，</br>同时能够转换为`T*`类型                          |
| `shared_ptr<T> p(u)`    | `p`从`unique_ptr` `u`哪里接管了对象的所有权；</br>将`u`置为空                                                    |
| `shared_ptr<T> p(q, d)` | `p`接管了内置指针`q`所指向的对象的所有权。</br>`q`必须能转换为`T*`类型。</br>`p`将使用**可调用对象**`d`来代替`delete` |
| `p.reset()`  </br> `p.reset(q)` </br> `p.reset(q.d)`                      |  若`p`是唯一指向其对象的`shared_ptr`，</br>`reset`会释放此对象。</br>若传递了可选参数`q`，</br>会令`p`指向`q`，否则会将`p`置为空。</br>若还传递了参数`d`，</br>那么就会使用`d`而不是`delete`来释放`q`                                                                                                           |

#### 不要混合使用普通指针和智能指针

考虑下面的代码：

```C++
// 设已有函数：
void process(shared_pre<int> ptr);

int *x(new int(1024));  // 危险：x是一个普通指针，不是一个智能指针
process(x);             // 错误：不能使用隐式转换
process(shared_ptr<int>(x)); // 正确但是指针会被释放！
// 行为未定义
int i = *x;
```

在上面的调用中，我们将一个临时`shared_ptr`传递给`process`。当这个调用所在的表达式结束的时候，这个临时对象会被销毁。销毁这个临时变量会递减引用计数，此时引用计数将变为**0**。因此，**当临时对象被销毁时，它所指向的内存会被释放**。

因此，当`i`尝试解引用`x`的时候，其在试图访问一个已经被释放的动态内存。


> [!Tips] 提示
> 当我们使用一个`shared_ptr`绑定到一个普通指针的时候，我们就将内存管理的责任交给了智能指针。一旦这样做，**我们就不应该在使用内置指针来访问智能指针所维护的内存**。

#### 不要使用`get`初始化另一个智能指针或为智能指针赋值

> 智能指针类型定义了一个名为`get`的函数，它返回一个内置指针，指向智能指针管理的对象。此函数是为了这样的情况设计的：我们需要向不能使用智能指针的代码传递一个内置指针。==使用`get`返回的指针的代码不能`delete`此指针。==


> [!Warning] 警告
> `get`用来将指针的访问权限传递给代码。你只有在确定代码不会`delete`指针的情况下，才能使用`get`。特别是，**永远不要用`get`初始化另一个智能指针或者为另一个智能指针赋值。**

#### 其他`shared_ptr`操作

与赋值类似，`reset`会更新引用计数，如果需要的话，会释放`p`指向的对象。`reset`经常与`unique()`一起使用，来控制多个`shared_ptr`共享的对象。在改变底层对象之前，我么检查自己是否是当前对象仅有的用户。如果不是，那么在改变之前要制作一份新的拷贝。

```C++
// 如果我们不是唯一用户，那么我们就要用reset来改变这个对象的值
// 令引用计数递减
if (!p.unique())
{
	p.reset(new string(*p));
}
// 否则我们可以直接操作，而不去担心改变对象的值会引起其他地方的错误
*p += newVal;
```

## 12.1.4 智能指针和异常

在使用智能指针的时候，即使程序块过早结束，智能指针类也能确保在内存不再需要时将其释放。而这是`new`和`delete`所做不到的。

```c++
void f()
{
	shared_ptr<int> sp(new int(42));
	// 代码出现异常，且并没有被捕获
}   // 函数结束时，shared_ptr依然释放内存
```

### 智能指针和哑类

在我们使用一些为C编写的库的时候，我们通常都需要自己显式地去释放资源。

```C++
// 库所提供的API
struct destination;
struct connection;
connection connect(destination*);
void disconnect(connection);

// C风格代码 in C++
void f(destination &d)
{
	connection c = connect(&d);
	// 使用连接
	// 如果我们在函数结束前忘记调用disconnect，那么就无法关闭c
}
```

为了避免忘记释放内存的情况出现，使用`shared_ptr`来保证`connection`被正确地关闭，是十分有效的方法。

### 使用我们自己的释放操作

默认情况下，`shared_ptr`假定它们所指向的是动态内存。因此当一个`shared_ptr`被销毁的时候，它默认的对它管理的指针进行`delete`操作。为了使`shared_ptr`能够**管理非动态内存**，我们需要定义我们自己的函数来进行释放操作。我们称之为***删除器（deleter）***。

^connection
```
// deleter
void end_connection(connection* p) { disconnect(*p); }

// C++风格代码
void f(destination &d)
{
	connection c = connect(&d);
	shared_ptr<connection> p(&c, end_connection);
	// 当f退出的时候（即使是因为异常而退出），connection也会被正常关闭
}
```

> [!Warning] 警告
> 智能指针可以提供对动态分配的内存安全而又方便的管理。但这建立在正确使用的前提下。为了正确使用智能指针，我们必须坚持一些基本规范：
>
> * 不使用相同的内置指针初始化（或者`reset`）多个智能指针
> *  不`delete` `get()` 返回的指针
> * 不使用`get()`初始化或`reset`另一个智能指针
> * 如果你使用`get()`返回的指针，记住当最后一个对应的智能指针销毁后，你的指针就变为无效了
> * 如果你使用智能指针管理的资源不是`new`分配的资源，那么需要传递给他一个`deleter`

## 12.1.5 `unique_ptr`

一个`unique_ptr`**拥有**它所指向的对象。某个时刻只能有一个`unique_ptr`指向一个给定的对象。当`unique_ptr`销毁的时候，它所指向的对象也被销毁。

> 尝试拷贝`unique_ptr`时编译器并不会永远给出易于理解的报错信息：
> 
> ```C++
> unique_ptr<int> up(new int(1024));
> auto p = up;
> ```
>
> ![奇怪的报错](C++%20Primer.assets/第12章%20动态内存与智能指针.assets/Pasted%20image%2020220701105256.png)

与`shared_ptr`不同，没有类似于`make_shared()`这样的函数存在。当我们定义一个`unique_ptr`的时候，我们需要将其绑定到一个`new`返回的指针上，并且***必须采用直接初始化的方式***。

| 操作          | 含义                                           |
| ------------- | ---------------------------------------------- |
| `u = nullptr` | 释放`u`指向的对象，将`u`置为空                 |
| `u.release()` | `u`放弃对指针的控制权，返回指针，并将`u`置为空 |
| `u.reset()`</br>`u.reset(q)`</br>`u.reset(nullptr)`              |如果提供了内置指针`q`，令`u`指向这个对象；否则置为空</br>但无论是哪种方式，`u`的现有指针都将被释放                                                |

在使用`release`之后，我们就切断了`unique_ptr`与它所指向的对象的联系。我们当然可以将`release`返回的指针交给一个内置指针，但是就**需要记得自己删除**。并且，对于`unique_ptr`而言，`get()`函数依然存在，但是就不能对`get()`返回的内容进行`delete`操作。

### 传递`unique_ptr`参数和返回`unique_ptr`

不能拷贝`unique_ptr`的规则有一个例外：***我们可以拷贝或者赋值一个要被销毁的`unique_ptr`***。在这样的情况下，编译器将会进行***移动构造***。

```C++
unique_ptr<int> clone1(int p)
{
	return unique_ptr<int>(new int(p));
}

unique_ptr<int> clone2(int p)
{
	unique_ptr<int> tmp(new int(p));
	// ...

	return tmp;
}
```

> [!NOTE] 向后兼容：`auto_ptr`
> 标准库的较早版本包含了一个名为`auto_ptr`的类，它具有`unique_ptr`的部分特性，但不是全部。特别是，我们不能在容器中保存`auto_ptr`，也不能从函数中返回`auto_ptr`
>
> 虽然`auot_ptr`仍是标准库的一部分，但是编写程序的时候应当使用`unique_ptr` 

### 向`unique_ptr`传递删除器

类似`shared_ptr`，我们可以在声明或者`reset`的时候提供一个自己的删除器。但是需要注意的是，`shared_ptr`和`unique_ptr`在对待删除器的策略上大不相同。***删除器是传递给`shared_ptr`的一个可调用对象，而对于`unique_ptr`而言，删除器是类型本身的一部分。*** 如何处理删除器的差异，其实就是这两个类功能上的差异。这部分内容将在**模板**中进一步探讨。

我们可以利用`unique_ptr`重写在[前文](#^connection)中编写的程序：

```C++
void f(destination &d)
{
	connection c = connect(&d);
	unique_ptr<connection, decltype(end_connection)*>
		p(&c, end_connection);
}
```

此处我们使用了`decltype`来知名函数指针类型。由于`decltype(end_connection)`返回一个哈数类型，所以我们必须添加一个`*`来说明我们正在使用这个类型的一个指针。

## 12.1.6 `weak_ptr`

`weak_ptr`是一种不控制所指向对象生存期的智能指针，它指向由一个`shared_ptr`管理的对象。将一个`weak_ptr`绑定到一个`shared_ptr`不会改变`shared_ptr`的引用计数。一旦最后一个指向对象的`shared_pre`被销毁，对象就会被释放。**即使有`weak_ptr`指向对象，对象也还是会被释放，因此，`weak_ptr`的名字抓住了这种智能指针“弱共享”的特点**

| 语句            | 解释                                                          |
| --------------- | ------------------------------------------------------------- |
| `w = p`         | `p`可以是一个`shared_ptr`或一个`weak_ptr`。</br>赋值后二者共享对象 |
| `w.reset()`     | 将`w`置为空                                                   |
| `w.use_count()` | 与`w`共享对象的`shared_ptr`的数量                             |
| `w.expired()`   | 若`w.use_count()`为0，返回`true`，否则返回`false`        |
| `w.lock()`                 | 如果`expired`为`true`，返回一个空的`shared_ptr`</br>否则返回一个指向`w`的对象的`shared_ptr`                                                             |

当我们创建一个`weak_ptr`的时候，要用一个`shared_ptr`来初始化它。

由于对象可能不存在，我们不能使用`weak_ptr`来直接访问，我们需要调用`lock()`

```C++
auto p =  make_shared<int>(42);
weak_ptr<int> wp(p);

// 如果np不为空，那么条件成立
if (shared_ptr<int> np = wp.lock())
{
	// 在if中，np与p共享对象
}
```

在上面这段代码中，只有当`lock`调用返回`true`的时候我们才会进入`if`。在`if`中，使用`np`访问共享对象是安全的。

### 检查指针类

> `weak_ptr`的存在的意义，就是辅助`shared_ptr`完成任务，并且避免***循环引用***。

考虑这样一个双向链表：

```C++
struct Node
{
	int _data;
	shared_ptr<Node> _next;
	shared_ptr<Node> _prev;
};

int main()
{
	shared_ptr<Node> sp1(new Node);
	shared_ptr<Node> sp2(new Node);
	sp1->_next = sp2;
	sp2->_prev = sp1;

	cout << "use count of node1: " << sp1.use_count() << endl;
    cout << "use count of node2: " << sp2.use_count() << endl;

	return 0;
}
```

输出：

```
count of node1: 2
count of node2: 2
```

可以发现，每个节点的地址被引用了两次：第一次用于操作节点本身；第二次用于记录前后键。

