# Function语义学

<p align="right">——The Semantics of Function</p>

> C++支持三种类型的成员函数：static/nonstatic和virtual，每一种类型被调用的方式都不相同

[TOC]

## 4.1 Member的各种调用方式

> 回顾历史，原始的“C with classes”只支持非静态成员函数。Virtual函数是在20世纪80年代被加入的。Static member function是最后被引入的一种函数类型。

### Nonstatic Member Function(非静态成员函数)

C++的设计准则之一就是：非静态成员函数至少必须和一般的非成员函数有相同的效率。编译器在这其中对成员函数进行了一系列转化，使之最后效率能够和普通函数相媲美：

1. 改写函数签名，安插一个额外参数到成员函数中，用以提供一个存取管道，使类对象得以将此函数调用。该额外函数被称为`this`指针。
2. 将每一个“对非静态数据成员的存取操作”经由`this`指针来进行存取。
3. 将成员函数重新写成一个外部函数，将函数名称经过“manling”处理，使之在程序中成为独一无二的词汇

当然，对于返回值，还可能会有NRV优化。

#### 名称的特殊处理（Name Mangling）

一般而言，member的名称会被加上类的名称，形成独一无二的命名。

而由于成员函数可以被重载（overloaded），所以需要更广泛的mangling手法，以提供绝对独一无二的名称。通常的做法是在加上类的名称之后，再在函数名后面跟上参数列表的类型。（但是如果声明了`extern "C"`，就会抑制效果）

目前的编译器还没有统一的编码方法。

在目前的编译系统中，有一种所谓的demangling工具，用来拦截名称并将其转换回去。使用者可以仍然处于“不知道内部名称”的莫大幸福之中。

### Virtual Member Functions(虚成员函数)

如果`normalize()`是一个虚成员函数，那么以下调用：

```c++
ptr->normalize();
```

就会被内部转化为：

```c++
(*ptr->vptr[1])(ptr);
```

其中：

+ `vptr`表示虚函数表指针。
+ `1`是虚函数的下标，关联到`normalize`函数
+ 第二个`vptr`代表了`this`指针

如果虚成员函数被声明为`inline`，会更有效率。其决议（resolved）方式会和非静态成员函数一样，同时虚函数实例可以被扩展（expand）开来，提供极大的效率利益。

### Static Member Functions(静态成员函数)

静态成员函数的主要特性就是，它没有`this`指针。以下的次要特性统统源于其主要特性：

+ 它不能够直接存取其类中的非静态成员
+ 它不能够被声明为`const`/`volatile`/`virtual`
+ 它不需要经由成员被调用，即使我们可以使用普通成员函数的调用方式来调用它

像前文提到的一样，静态成员函数的名称也会经过mangling处理，例如`SFv`代表static member function,参数列表为`void`

如果去一个静态成员函数的指针，获得的将是其在内存中的入口地址。由于静态成员函数没有`this`指针，所以其地址的类型并不是一个“指向class member function的指针”，而是一个“非成员函数指针”。也就是说：

```c++
&Point3d::object_count();
```

会得到一个数值，其类型为：

```c++
unsigned int(*)();
```

而不是：

```c++
unsigned int (Point3d::*)();
```

由于静态成员函数在表现上像普通函数，它提供了一个意想不到的好处：成为一个callback函数。
