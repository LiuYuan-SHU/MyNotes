# 构造、析构、拷贝语义学

<p align="right">——Semantics of Construction, Destruction, and Copy</p>

[TOC]

## 5.1 “无继承”情况下的对象构造

一个对象的生命，是该对象的一个执行期属性。局部对象的生命从声明开始，到块结束的时候结束。全局对象的生命和整个程序的生命相同。`heap`对象的生命从他被`new`运算符配置出来开始，到它被`delete`销毁为止。

C和C++的一个差异就在于，BSS data segment在C++中相对地不重要。C++的所有全局对象都被以“初始化过的数据”来对待。

### 抽象数据类型（Abstract Data Type）

如果要将一个类中所有的成员都设定初始常量值，那么提供一个explicit initialization list会比较有效率些（比起意义相同的constructor的inline expansion而言）。例如：

```c++
void mumble()
{
    Point local1 = {1.0, 1.0, 1.0};
    Point local2;
    
    // 相当于一个inline expansion
    // 但是会更快些
    local2._x = 1.0;
    local2._y = 1.0;
    local2._z = 1.0;
}
```

Explicit initializaiton list带来三个缺点：

1. 只有当类成员都是`public`的时候，此方法才奏效

    ```c++
    list<int> l = {1, 2, 3, 4};
    ```

    并不是explicit initilization list，而是调用了其构造函数`list( std::initializer_list<T> init, const Allocator& alloc = Allocator() );`

2. 只能指定常量，因为它们在编译器就被编译求值

3. 由于编译器并没有自动施行，所以初始化行为的失败可能性会比较高

那么，explicit initialization list所带来的效率优点，能够补偿其软件工程上的缺点吗？一般而言不行。但是在某些特殊情况下又不一样。例如，或许我们需要在程序中构建庞大的数据结构，例如调色盘（color palette），或者是我们需要把大量的常量数据倾倒给程序，那么explicit initialization list的效率就会比inline constructor好得多，尤其是对于全局对象而言。

在编译器层面，会有一个优化机制用来识别inline constructor，后者简单地提供一个member-by-member的常量制定操作。然后编译器会抽取出那些值，并且对待它们就好像是explicit initialization list所提供的一样，而不会把构造函数扩展称为一系列的赋值语句。

