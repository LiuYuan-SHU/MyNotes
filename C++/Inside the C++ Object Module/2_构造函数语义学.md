# 构造函数语义学

<p align="right"><b><i>——The Semantics of Constructors</i></b></p>

关于C++，最常听到的一个抱怨就是，编译器背着程序员做了太多事情。

## 2.1 Default Constructor的构造操作

> <i>default constructors……在需要时被编译器产生出来。</i>

关键字眼是“在需要的时候”。被谁需要？做什么事情？

### “需要”是编译器认为需要，而不是我们的程序需要

```c++
class Foo { public: int val; Foo *pNext; };

void foo_bar()
{
    // 我们需要bar的所有成员都是0
    Foo bar;
    if ( bar.val || bar.pNext ) { /*...*/ }
}
```

在这个例子中，正确的程序语义是要求`Foo`有一个默认构造函数，可以将它的两个对象都初始化为0。上面这段代码并不符合我们对“需要”的定义。其差别在于，一个是程序的需要，一个是编译器的需要。

<p align="center"><b><i>程序如果需要，那么是程序员的责任，而不是编译器的。</i></b></p>

一个默认构造函数会被合成出来，当且仅当编译器需要它的时候。并且，合成出的构造函数只完成编译器需要它完成的工作，我们不能期待这个合成出的构造函数会为我们做任何额外我们所希望的事。换言之，假设编译器真的为我们合成了构造函数，我们也不能去期望里面的两个data member被初始化为0.

> <center><b><i>If there is no user-declared constructor for class X, a default constructor is implicitly declared…. </br>A constructor is *trivial* if it is an implicitly declared default constructor….</i></b></center>

******

但是，存在四种情况，编译器生成的默认构造函数将不是“trivial”的：

### “带有Default Constructor”的Member Class Object

如果一个类没有任何constructor，但是它内部含有一个成员对象，而后者有一个默认构造函数，那么这个类的implicit default constructor就不是"trivial"的：**编译器需要为该类合成一个default constructor**

这样的操作产生了一个问题：在C++各个不同的编译模块中（此处指不同的文件）编译器如何避免合成出多个default destructor？解决方法是**把合成的default constructor / copy constructor / destructor / assignment copy operator都以`inline`的方式完成**。一个`inline`函数有静态链接（static linkage），不会在文件以外被看到。

如果函数太复杂，不适合做成内联函数，就会合成出一个 *explicit non-inline static function instance*。

例如，在如下的程序片段中，编译器将为`class Bar`合成一个default constructor：

```c++
class Foo { public: Foo(), Foo( int ) ... };
class Bar { public: Foo foo; char *str; };

void foo_bar()
{
    Bar bar;
    // ...
}
```

被合成的`Bar` default constructor内含必要的代码，能够调用class `Foo`的default constructor来处理成员对象`Bar::foo`，**但它不产生任何代码来初始化`Bar::str`**。将`Bar::foo`初始化是编译器的责任，但是将`Bar::str`初始化是程序员的责任。

******

那么，我们添加一个构造函数好了：

```c++
Bar::Bar()
{
    str = 0;
}
```

现在我们程序员自己该做的事情做完了（虽然一个合格的程序员还是应该显式地去构造每一个成员），但是编译器还需要初始化成员对象`foo`。但由于default constructor已经被显式地定义出来，编译器不能再合成第二个。

编译器的行动是：

<center><b><i>如果class A内含一个或一个以上的member class objects</br>那么class A的每一个constructor必须调用每一个member classes的default constructor。</i></b></center>

编译器会扩充已经存在的constructors，在其中安插一些代码，***使得user code被执行之前，先调用必要的default constructors。***

也就是说，可能会是这个样子：

```c++
Bar::Bar()
{
    foo.Foo:Foo();
    str = 0;
}
```

如果有多个class member objects都要求constructor初始化操作，C++就将以member objects在class中声明的顺序来调用各个constructors，这些代码将被安插在explicit user code之前。

