# 构造函数语义学

<p align="right"><b><i>——The Semantics of Constructors</i></b></p>

>  关于C++，最常听到的一个抱怨就是，编译器背着程序员做了太多事情。

## 2.1 Default Constructor的构造操作

> <i>default constructors……在需要时被编译器产生出来。</i>

关键字眼是“在需要的时候”。被谁需要？做什么事情？

### “需要”是编译器认为需要，而不是我们的程序需要

```c++
class Foo { public: int val; Foo *pNext; };

void foo_bar()
{
    // 我们需要bar的所有成员都是0
    Foo bar;
    if ( bar.val || bar.pNext ) { /*...*/ }
}
```

在这个例子中，正确的程序语义是要求`Foo`有一个默认构造函数，可以将它的两个对象都初始化为0。上面这段代码并不符合我们对“需要”的定义。其差别在于，一个是程序的需要，一个是编译器的需要。

<p align="center"><b><i>程序如果需要，那么是程序员的责任，而不是编译器的。</i></b></p>

一个默认构造函数会被合成出来，当且仅当编译器需要它的时候。并且，合成出的构造函数只完成编译器需要它完成的工作，我们不能期待这个合成出的构造函数会为我们做任何额外我们所希望的事。换言之，假设编译器真的为我们合成了构造函数，我们也不能去期望里面的两个data member被初始化为0.

> <center><b><i>If there is no user-declared constructor for class X, a default constructor is implicitly declared…. </br>A constructor is *trivial* if it is an implicitly declared default constructor….</i></b></center>

******

但是，存在四种情况，编译器生成的默认构造函数将不是“trivial”的：

### “带有Default Constructor”的Member Class Object

如果一个类没有任何constructor，但是它内部含有一个成员对象，而后者有一个默认构造函数，那么这个类的implicit default constructor就不是"trivial"的：**编译器需要为该类合成一个default constructor**

这样的操作产生了一个问题：在C++各个不同的编译模块中（此处指不同的文件）编译器如何避免合成出多个default destructor？解决方法是**把合成的default constructor / copy constructor / destructor / assignment copy operator都以`inline`的方式完成**。一个`inline`函数有静态链接（static linkage），不会在文件以外被看到。

如果函数太复杂，不适合做成内联函数，就会合成出一个 *explicit non-inline static function instance*。

例如，在如下的程序片段中，编译器将为`class Bar`合成一个default constructor：

```c++
class Foo { public: Foo(), Foo( int ) ... };
class Bar { public: Foo foo; char *str; };

void foo_bar()
{
    Bar bar;
    // ...
}
```

被合成的`Bar` default constructor内含必要的代码，能够调用class `Foo`的default constructor来处理成员对象`Bar::foo`，**但它不产生任何代码来初始化`Bar::str`**。将`Bar::foo`初始化是编译器的责任，但是将`Bar::str`初始化是程序员的责任。

******

那么，我们添加一个构造函数好了：

```c++
Bar::Bar()
{
    str = 0;
}
```

现在我们程序员自己该做的事情做完了（虽然一个合格的程序员还是应该显式地去构造每一个成员），但是编译器还需要初始化成员对象`foo`。但由于default constructor已经被显式地定义出来，编译器不能再合成第二个。

编译器的行动是：

<center><b><i>如果class A内含一个或一个以上的member class objects</br>那么class A的每一个constructor必须调用每一个member classes的default constructor。</i></b></center>

编译器会扩充已经存在的constructors，在其中安插一些代码，***使得user code被执行之前，先调用必要的default constructors。***

也就是说，可能会是这个样子：

```c++
Bar::Bar()
{
    foo.Foo:Foo();
    str = 0;
}
```

如果有多个class member objects都要求constructor初始化操作，C++就将以member objects在class中声明的顺序来调用各个constructors，这些代码将被安插在explicit user code之前。

### “带有Default Constructor”的Base Class

假设存在一个基类，如果这个基类派生出的派生类有一个默认的构造函数，而这个基类没有默认的构造函数，编译器就会为这个基类创建一个默认构造函数。

### “带有一个Virtual Function”的Class

在以下的情况下，也需要合成出default constructor：

1. class声明（或继承）了一个virtual function
2. class派生自一个继承链，其中有一个或更多的virtual base classes。

不管是哪一种情况，在编译期间都会发生以下的行为：

1. 一个virtual function table(vtbl)会被编译器产生出来，内放class的virtual functions地址
2. 在每一个class object中，一个额外的pointer member（vptr）会被编译器合成出来，内含相关的class vtbl的地址。

### “带有一个Virtual Base Class”的Class

Virtual base class的实现在不同的编译器之间有极大的差异。然而，这些实现的共同点在于，虚基类在每一个派生类对象中的位置（内存），会在执行期准备妥当。

```mermaid
classDiagram
X <|-- A
X <|-- B
A <|-- C
B <|-- C
```

对于上面的UML图，我们编写如下的代码：

```c++
class X 						{ public: int i; }
class A : public virtual X 		{ public: int j; }
class B : public virtual X 		{ public: double d; }
class C : public A, public B 	{ public: int k; }

// 编译器无法在编译时期决定（resolve） pa->X::i 的位置
void foo( constA* pa ) { pa->i = 1024; }

int main()
{
    foo( new A );
    foo( new C );
}
```

编译器必须改变“执行存取”的那些代码，使得`X::i`可以延迟到执行期才能决定下来。

原先`cfront`的做法是：在derived class object的每一个virtual base classes中安插一个指针来完成

而我们也再次给出一个可能的实现方式：

```c++
// 编译器可能做出的转变操作
void foo( const A* pa )
{
    pa->__vbcX->i = 1024;
}
```

其中，`__vbcX`代表`virtual base class X`。

> As you've no doubt guessed by now, the initialization of __vbcX (or whatever implementation mechanism is used) is accomplished during the construction of the class object. For each constructor the class defines, the compiler inserts code that permits runtime access of each virtual base class. In classes that do not declare any constructors, the compiler needs to synthesize a default constructor. 

`__vbcX`或者任何类似的机制，都是在对象构造期间完成的。对于类所定义的每一个构造函数，编译器都会在其中插入一些代码，来满足在运行期间访问虚基类的需求。对于那些没有声明任何构造函数的类，编译器需要为他们生成默认构造函数。

### 总结

通过上面的讨论，存在4种情况，会导致编译器为没有声明构造函数的类生成默认构造函数。C++标准将这些合成的构造函数称为implicit nontrivial default constructor。***被合成的构造函数只能满足编译器（而非程序）的需要。***这些构造函数被合成，只是为了满足机制上的需要（合成、继承、虚继承、多态）。至于不在上述4种情况之列，又没有声明任何构造函数的类，我们说它们拥有的是implicit trivial default constructors。***它们实际上不会被编译器合成出来。***

在合成的默认构造函数中，只有base class subobjects和member class objects会被初始化。所有其他的nonstatic data mamber（如整数、整数指针、整数数组等等）都不会被初始化。这些初始化操作对程序而言或许有必要，但对编译器则非必要。如果程序需要一个“把某个指针设为0”的default constructor，那么提供它的人应当是程序员。

> Programmers new to C++ often have two common misunderstandings: 
>
> 1. That a default constructor is synthesized for every class that does not define one 
> 2. That the compiler-synthesized default constructor provides explicit default initializers for each data member declared within the class
>
> As you have seen, neither of these is true.

## 2.2 Copy Constructor的构造操作

有三种情况，会用一个object的内容作为另一个class object的初值。

1. 最明显的一种情况当然是对一个object做显式地初始化操作，像这样：

    ```c++
    class X { ... };
    X x;
    X xx = x;
    ```

2. 或者是将对象作为参数直接传递给函数：

    ```c++
    extern void foo ( X x );
    
    void bar()
    {
    	X xx;
        
        foo( xx );
    }
    ```

3. 然后是将对象作为函数返回值：

    ```c++
    X foo_bar()
    {
        X xx;
        return xx;
    }
    ```

假如我们显示地定义了一个拷贝构造函数（copy constructor），例如：

```c++
X::X( const X& x );
Y::Y( const Y& y, int = 0 );
```

那么在大部分情况下，当一个类对象以另一个对象实例作为初值，上述的构造函数就会被调用。这可能会导致一个临时性的类对象的产生，或者是改变实际的代码（编译器会优化我们的代码），或者二者都有。

> This may result in the generation of a temporary class object or the actual transformation of program code (or both).

### Default Memberwise Initialization

> 如果类没有显式地提供一个拷贝构造函数（explicit copy constructor），会如何？

当类对象以相同的类的另一个对象作为初值，其内部是以所谓的“default memberwise initialization”方式完成的。意即，它把每一个内建的或派生的数据成员的值，从某个对象拷贝到另一个对象上。不过，它并不会拷贝其中的成员类对象，而是以递归的方式执行“memberwise initialization”。例如：

```c++
class String
{
public:
	// ... 没有提供explicit copy constructor
private:
    char *str;
    size_t len;
};
```

一个`String`对象的“default memberwise initialization”发生在这种情况下：

```c++
String noun("book");
String verb = noun;
```

其实现为：

```c++
verb.str = noun.str;
verb.len = noun.len;
```

接下来，如果我们将`String`类声明为`Word`类的成员，像这样：

```mermaid
classDiagram

Word --> String

class Word {
	-int _occurs
  	-String _word
}

```

```C++
class Word
{
public:
    // ... 同样，我们没有提供explicit copy constructor
private:
    int _occurs;
    String _word;
};
```

那么，一个`Word`对象的""default memberwise initialization"会拷贝`_occurs`，然后再在`_word`上调用`memberwise initialization`。于是形成了一个递归的拷贝。

“如果一个类没有定义出拷贝构造，编译器就会自动为它生成一个”，这句话也是错的，而应该是：***Default constructors and copy constructors…are generated (by the compiler) where needed.***

> <center><b><i>A class object can be copied in two ways, by initialization (what we are concerned with here)…and by assignment (treated in Chapter 5). Conceptually (my italics), these two operations are implemented by a copy constructor and copy assignment operator.</i></b></center>
>
> <p align="right">——Stanley B. Lippman</p>
>
> <center><b><i>一个类对象可以用两种方式复制得到，一种是被初始化（也就是我们这里关心的），另一种是被指定（assignment，第5章讨论）。从概念上而言，这两个操作分别是以copy constructor和copy assignment operator完成的。</i></b></center>
>
> <p align="right">——侯捷</p>

就像default constructor，C++标准将拷贝构造分为trivial和nontrivial。只有nontrivial的实例代码才会被合成。***决定一个拷贝构造是否为trivial，在于类是否展现出所谓的“bitwise copy semantics”***

### Bitwise Copy Semantics（位逐次拷贝）

考虑如下代码：

```c++
#include "Word.h"

Word noun("book");

void foo()
{
    Word verb = noun;
}
```

基于`Word`的不同实现方式，`foo`中的拷贝方式也会有不同。

如果`Word`得设计者定义了一个拷贝构造，那么，`verb`的初始化操作会调用它；但如果`Word`没有定义显式地拷贝构造函数，那么是否会有一个编译器合成的实例被调用？这取决于类是否展现“Bitwise Copy Semantics”。

#### `Word`实现1——展现“Bitwise Copy Semantics”

```c++
class Word
{
public:
    Word( const char* );
    ~Word() { delete [] str; }
    // ...
private:
    int		cnt;
    char* 	str;
};
```

这种情况下并不需要合成一个default copy constructor。因为上述代码展现了“default copy semantics”，而`verb`的初始化也不需要调用任何的函数（也就是说，我们只需要调用拷贝构造，而不需要在其中再调用别的函数）。当然，这里的实现是灾难性的，因为其中涉及到了深浅拷贝的问题。

#### `Word`实现2——不展现`Bitwise Copy Semantics`

```c++
class String
{
public:
    String( const char* );
    String( const String& );
    ~String();
    // ...
};

class Word  
{
public:
    Word( const String& );
    ~Word();
    // ...
private:
    int		cnt;
    String	str;
};
```

在这种情况下，编译器必须合成一个拷贝构造函数，这样才能调用`String`类的拷贝构造函数。我们可以假设合成的代码是这样的：

```c++
inline Word::Word( const Word& wd )
{
    str.String::String( wd.str );
    cnt = wd.cnt;
}
```

有一点值得注意：在合成出来的拷贝构造函数中，所有的不是类对象成员的成员（nonclass members）也会被复制，如同我们所期待的那样。

### 不要Bitwise Copy Semantics！——4种情况

什么时候一个类不展现出“bitwise copy semantics”？有四种情况：

1. 当类内含一个成员对象而后者的类声明中含有一个拷贝构造时（无论这个拷贝构造是由设计者显式声明，还是由编译器合成）
2. 当类继承自一个基类，而后者存在一个拷贝构造的时候（同样，无论是合成的还是设计的）
3. 当一个类设计了一个或多个虚函数时
4. 当类派生自一个继承链，其中有一个或多个的虚基类时

1/2没有太多讨论的意义，因为我们需要一个拷贝构造，在其中去调用成员的拷贝构造。我们主要讨论的是后面两点。

### 重新设定Virtual Table的指针

让我们回忆我们在之前讨论过的，编译器会在编译期间对代码进行的扩充操作（只要一个类声明了虚函数就会如此）：

+ 增加一个虚函数表（vtbl），内含每一个有作用的虚函数地址
+ 一个指向虚函数表的指针（vptr），安插在每一个类对象中

很显然，如果编译器对于每一个新产生的类对象的虚函数表指针不能成功而正确地设定好初值，将导致严重的后果。因此，***当编译器导入一个虚函数表指针到类中的时候，这个类就不再展现"bitwise semantics"了。***现在，编译器需要合成出一个拷贝构造来将虚函数表指针初始化：

```c++
class ZooAnimal
{
public:
    ZooAnimal();
    virtual ~ZooAnimal();
    
    virtual void animate();
    virtual void draw();
    // ...
    
private:
    // ZooAnimal的成员函数所需要的数据
};

class Bear: : pulic ZooAnimal 
{
public:
    Bear();
    void animate();	// 虽然此处没有写Virtual，但是同样是虚函数
    void draw();	// 同上
    virtual void dance();
    // ...
private:
    // 需要的数据
};
```

******

当我们用`ZooAnimal`的对象初始化另一个`ZooAnimal`对象、或者我们用`Bear`的一个对象去初始化另一个`Bear`对象的时候，都可以靠bitwise copy semantics完成。举个例子：

```c++
Bear yogi;
Bear winnie = yogi;
```

`yogi`会被default `Bear` constructor初始化。而在构造函数中，`yogi`的虚函数指针被设定指向`Bear`类的虚函数表（靠编译器安插的代码完成）。因此，把`yogi`的vptr拷贝给`winnie`是安全的。

******

同样，当我们使用一个派生类来初始化其基类的时候，其vptr的复制也必须要保证安全，例如：

```c++
ZooAnimal franny = yogi;	// 这会产生切割（sliced）行为
```

`franny`的vptr不可以被设定指向`Bear`类的虚函数表，这是自然的。也就是说，合成出来的`ZooAnimal` copy constructor会显式设定对象的vptr指向`ZooAnimal`类的虚函数表，而不是直接把右边的类对象的vptr值直接拷贝过来。

### 处理Virtual Base Class Subobject（未完成）

### 总结

我们已经看过4种情况，在这些情况下类不再保持“bitwise copy semantics”，而且default copy constructor如果没有被声明的话，就会被视为nontrivial。在这些情况下，如果缺乏一个已经声明的copy constructor，编译器为了正确处理“以一个类对象作为另一个类对象的初值”，必须合成出一个拷贝构造函数。

