# 函数模板

## 基本范例

```c++
template <typename T>
T Sub(T v1, T v2)
{
    return v1 - v2;
}

int main()
{
    int subv = Sub(3, 5);
    cout << "subv = " << subv << endl;
    double sub2 = Sub(4.7, 2.1);
    cout << "sub2 = " << sub2 << endl;
}
```

上述是一个函数模板的典型范例，因为函数参数的类型没有确定，所以用`T`表示。这个`T`可以称作**模板参数**。更确切地说，是一个**类型模板参数**，因为它表示的是一个**类型**。

1. 模板的定义以`template`关键字开头
2. `typename`可以用`class`取代（但是推荐使用`typename`），但这里的`class`并没有类的意思（有些人习惯使用`typename`表示对应的模板实参可以是任意类型，而使用`class`表明对应的模板实参必须是一个类类型）

## 实例化

在前面的代码中，分别使用了`int`和`double`类型的参数调用了`Sub()`函数模板，因此在编译的时候，编译器就会对这个函数模板进行实例化。所谓的实例化就是用具体的参数类型来代替“类型模板参数”的过程，也称为代码生成器。

针对不同的类型，每种类型都会被实例化一次。所以，`Sub()`函数模板一共会被实例化两次，相当于产生了两个`Sub()`函数：

```c++
int __cdecl Sub<int> (int, int);
double __cdecl Sub<double> (double, double);
```

为了能够实现这样的功能，在编译阶段，编译器需要能够找到函数模板的**函数体部分**。所以，函数模板的定义通常都是在头文件中实现的。

同时需要注意的是，对于上面的`Sub()`函数代码，参数的类型必须相同，即使是`Sub(1, 3.0)`也是不允许的，在推断函数模板类型这件事情上，是不能进行自动类型转换的，要求的是类型精确匹配。

当然，如果我们一定要这样做的话，我们可以自己指定参数类型：

```c++
Sub<double>(1, 3.0);
```



## 模板参数的推断

### 1. 常规的参数推断

考虑这样的函数：

```c++
template <typename T, typename U, typename V>
V Add(T tv1, U tv2)
{
    return tv1 + tv2;
}
```

如果我们这样调用代码：

```c++
Add(16, 17.8);
```

代码会报错。根据我们提供的参数，编译器能够很轻松的推断出`T`和`U`的类型，但是却不能够确定模板参数`V`。

所以，我们必须指定返回类型：

```c++
Add<..., ..., double>(15, 17.8);
```

但是，很遗憾的是，如果我们这样写，也是不行的。如果我们想要指定某一个模板参数，前面的参数也必须被指定。所以我们可以适当调整一下模板参数的位置：

```c++
template <typename V, typename T, typename U>
V Add(T tv1, U tv2);

Add<double>(15, 17.8);
```

这样就可以了。但是这样还是有些不方便，我们每次调用的时候还是会需要手动填写返回类型，有没有更简单的方式？答案是有的：

```c++
template <typename T, typename U>
auto Add(T tv1, U tv2) -> decltype(tv1 + tv2)
{
    return tv1 + tv2;
}
```

### 2. 各种推断的比较与空模板参数列表的推断

考虑这样的代码：

```c++
template <typename T>
T mydouble(T tmp_value)
{
    return tmp_value * 2;
}
```

对上述代码的调用，有很多方式：

1. 自动推断

    ```c++
    int result = mydouble(15);
    ```

    由于传入了`15`，因此模板参数`T`会被推断为`int`。

2. 指定类型模板参数

    同时指定实参和类型模板参数：

    ```c++
    int result2 = mydouble<int>(16.9);
    ```

    由于显示指定了模板的参数，因此不存在参数推断的情况。但是，因为模板参数为`int`，因此传入`16.9`，就会损失一定的数据

3. 指定空模板参数列表

    调用代码如下：

    ```c++
    auto result3 = mydouble<>(16.9);
    ```

    上述代码中，模板参数列表为空，实参传入16.9。那么，模板参数列表为空是什么意思呢？

    1. `mydouble`模板参数的类型依旧是通过实参`16.9`进行推断的，所以，推断出来的是`double`类型

    2. 在当前情况下，`< >`可能没有什么意义，但是如果还存在一个叫做`mydouble`的普通函数，那么它就会发挥一些作用：

        ```c++
        double mydouble(double val)
        {
            return val * 2;
        }
        ```

        如果进行下面的调用，调用的就是普通的`mydouble()`函数：

        ```c++
        auto result4 = mydouble(16.9);
        ```

        但是如果带上`< >`，那么调用的就是函数模板：

        ```c++
        auto result5 = mydouble<>(16.9);
        ```

    所以，空模板参数列表的用处是可以明确地指出我们需要调用的是函数模板，而不是普通的函数

## 重载

函数模板的重载与函数的重载比较相似，函数（函数模板）重载的概念是：函数（函数模板）名字相同，但**参数数量**或**参数类型**不同。编译器会根据调用时给出的具体实参，选择一个编译器认为最合适的函数模板实例化调用。

另外，普通函数也被视为函数模板的一种重载。

```c++
template <typename T>
void myfunc(T tmp_value)
{
    cout << "myfunc(T tmp_value) executed" << endl;
}

template <typename T>
void myfunc(T* tmp_value)
{
    cout << "myfunc(T* tmp_value) executed" << endl;
}

void myfunc(int tmp_value)
{
    cout << "myfunc(int tmp_value) executed" << endl;
}

int main()
{
    myfunc(12);	// myfunc(int tmp_value) executed
    char*p = nullptr;
    myfunc(p); // myfunc(T* tmp_value) executed
    myfunc(11.1); // myfunc(T tmp_value) executed
}
```

## 特化

> 特化代码通常代表从泛化版本中抽象出来的一个子集

> [test codes](./Test_codes/2_模板基础知识/1_template_specialization.cpp)

```c++
template <typename T, typename U>
void tfunc(T& temp_rv, U& tmp_rv2)
{
    cout << "tfunc 泛化版本" << endl;
    cout << temp_rv << endl;
    cout << temp_rv2 << endl;
}
```

### 1. 全特化

所谓的全特化，就是把泛化版本中所有模板参数都用具体的类型代替，构成一个特殊的版本（全特化版本），既然所有模板参数都用具体的类型代替了，那么`tfunc()`泛化版本中`template`后面尖括号中的内控就是空了

```c++
template <>
void tfunc<int, double>(int& tmp_rv, double& tmp_rv2)
{
    // ...
}
```

全特化实际上等价于实例化一个函数模板，并不等价于一个函数重载。

在遇到一个函数调用的时候，选择**普通函数**、函数模板（泛化）或函数模板特化版本都合适的时候，编译器首先选择普通函数，其次考虑特化版本，最后考虑泛化版本。

针对函数模板的特化版本的选择问题，如果恰好碰到两个模板特化版本都合适的情况，那么编译器会选择最合适的特化版本。在拿不准的时候，要多写代码测试

### 2. 偏特化（局部特化）

全特化是把所有类型模板参数都用具体的类型代表。而偏特化（局部特化）可以分为两个方面，一个是模板参数数量上的偏特化，一个是模板参数范围上的偏特化。

1. 模板参数数量上的偏特化

    需要注意的是，**对于模板参数数量上的偏特化来说，函数模板不能偏特化，**只有类模板可以偏特化。

    ```c++
    // 下面这段代码会报错：
    template<typename U>
    void tfunc<double, U>(double& tv1, U& tv2)
    {
        
    }
    ```

2. 模板参数范围上的偏特化

    所谓“参数范围”，比如原来是`int`，改为`const int`之后，类型的范围自然就小了。

    但是，实际上，也不存在函数模板的这种类型的特化，这种特化的本质是**重载**。

    ```c++
    template <typename T, typename U>
    void tfunc(const T& tv1, U& tv2)
    {
        
    }
    ```

3. 通过重载实现模板参数数量上的偏特化

    对于上面提到的“模板参数数量上的偏特化”，如果一定想要实现这样的功能，可以这样：

    ```c++
    template <typename U>
    void tfunc(double& tv1, U& tv2)
    {
        
    }
    ```

## 默认参数

函数模板可以提供默认的模板参数：

```c++
int mf(int tmp1, int tmp2)
{
    return 1;
}
typedef int(*FuncType)(int, int);

template <typename T, typename F = FuncType>
void testFunc(T i, T j, F funcPoint = mf)
{
    cout << funcPoint(i, j) << endl;
}
```

另外，函数模板的默认参数可以放在前面（这一点与后续讲解的类模板默认参数不一样，类模板参数一旦有一个是默认参数，则后续的参数都需要有默认值）。

## 非类型模板参数

```c++
template <typename T, typename U, int val = 100>
auto Add(T tv1, U tv2) -> decltype(tv1 + tv2 + val)
{
    return tv1 + tv2 + val;
}
```

从C++17开始，已经支持将非类型模板参数设置为`auto`。还要注意的是，指定非类型模板参数的时候，一般给的都是常量。

***关于非类型模板参数的类型问题，并不是任何类型的参数都可以作为非类型模板参数。***例如， `int`可以，但是`float`/`double`或者类类型（比如`string`就不可以）。不过`double*`这种指针类型也是可以的。

至于哪些类型可以，哪些类型不可以，可以实验得出。一般允许的类型有：

1. 整型或枚举类型
2. 指针类型
3. 左值引用类型
4. `auto`或者`decltype(auto)`。`decltype(auto)`的含义是，`auto`是要推导的类型，而`decltype`是推导指令

非类型模板参数主要是为了传递数组大小之类的信息，其目的是在提高程序运行效率等方面与C语言的数组进行竞争。

# 类模板、变量模板与别名模板

