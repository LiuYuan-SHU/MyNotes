[TOC]

# `new`、`delete`的进一步认识

## 总述与回顾

### `operator new`/`operator delete`与`new`/`delete`有什么关系？

1. `new`做两件事：

    1. 分配内存
    2. 调用构造函数初始化内存

    分配内存使用`operator new()`

2. `delete`做两件事：

    1. 调用析构函数
    2. 释放内存

    释放内存使用`operator delete()`

### 申请和释放数组

`new []`和`delete[]`需要配套使用。C++在为大多数类型分配数组空间时多分配了4字节的大小，只有一些类型在分配时不拥有这4个字节——内置类型或者无自定义析构函数的类类型。这4个字节保存了分配的空间的大小。

之所以要配套使用，就是因为当我们使用`delete[]`时，其会去检查那4个Byte，从而确定需要释放的内存大小。

当然，对于上面提到的两种类型可以使用`new[]`和`delete`，但是这是一种很差的编码习惯

## 从`new`说起

### `new`类对象时加与不加小括号的区别

对于类`A`来说，`new A`和`new A()`没有什么区别，它们都调用类的无参构造函数。但是，对于下面三种调用，有什么区别呢？

```c++
int* p1 = new int;
int* p2 = new int();
int* p3 = new int(100);
```

使用C++ Insights来看看编译器是怎么看待这段代码的：

```c++
int main()
{
  int * p1 = new int;
  int * p2 = new int{0};
  int * p3 = new int{100};
  return 0;
}
```

### `new`究竟做了什么？

让我们编写一段测试代码：

```c++
struct Test
{
    Test() {}

    int _val;
};

int main()
{
    Test *test = new Test();
}
```

再用compiler explorer看看关键的汇编码：

```assembly
Test::Test() [base object constructor]:
        push    rbp
        mov     rbp, rsp
        mov     QWORD PTR [rbp-8], rdi
        nop
        pop     rbp
        ret
main:
        push    rbp
        mov     rbp, rsp
        push    rbx
        sub     rsp, 24
        mov     edi, 4
        call    operator new(unsigned long)
        mov     rbx, rax
        mov     rdi, rbx
        call    Test::Test() [complete object constructor]
        mov     QWORD PTR [rbp-24], rbx
        mov     eax, 0
        mov     rbx, QWORD PTR [rbp-8]
        leave
        ret
```

可以看到，代码首先调用了`operator new()`，之后调用构造函数。

那么，`operator new()`到底是什么？很显然，是一个函数。既然是一个函数，那么就是可调用的。我们来试试：

```c++
int main()
{
    operator new(12);
}
```

没啥问题：

```assembly
main:
        push    rbp
        mov     rbp, rsp
        mov     edi, 12
        call    operator new(unsigned long)
        mov     eax, 0
        pop     rbp
        ret
```

我们可以通过查看visual studio的`new_scalar.cpp`来查看`operator new`的源码：

```c++
_CRT_SECURITYCRITICAL_ATTRIBUTE
void* __CRTDECL operator new(size_t const size)
{
    for (;;)
    {
        if (void* const block = malloc(size))
        {
            return block;
        }

        if (_callnewh(size) == 0)
        {
            if (size == SIZE_MAX)
            {
                __scrt_throw_std_bad_array_new_length();
            }
            else
            {
                __scrt_throw_std_bad_alloc();
            }
        }

        // The new handler was successful; try to allocate again...
    }
}
```

于是我们可以写出函数的调用关系：

```c++
A* pa = new A();
	operator new();
		malloc();
	A::A();
```

******

同时，如果我们给代码添加上析构函数，再`delete`一下：

```c++
struct Test
{
    Test() {}
    ~Test() {}

    int _val;
};

int main()
{
    Test *test = new Test();

    delete test;
}
```

再来看看汇编码：

```assembly
Test::Test() [base object constructor]:
        push    rbp
        mov     rbp, rsp
        mov     QWORD PTR [rbp-8], rdi
        nop
        pop     rbp
        ret
Test::~Test() [base object destructor]:
        push    rbp
        mov     rbp, rsp
        mov     QWORD PTR [rbp-8], rdi
        nop
        pop     rbp
        ret
main:
        push    rbp
        mov     rbp, rsp
        push    rbx
        sub     rsp, 24
        mov     edi, 4
        call    operator new(unsigned long)
        mov     rbx, rax
        mov     rdi, rbx
        call    Test::Test() [complete object constructor]
        mov     QWORD PTR [rbp-24], rbx
        mov     rbx, QWORD PTR [rbp-24]
        test    rbx, rbx
        je      .L4
        mov     rdi, rbx
        call    Test::~Test() [complete object destructor]
        mov     esi, 4
        mov     rdi, rbx
        call    operator delete(void*, unsigned long)
.L4:
        mov     eax, 0
        mov     rbx, QWORD PTR [rbp-8]
        leave
        ret
```

可以看到，先调用析构函数，再调用`operator delete`。

我们再来看看`delete_scalar.cpp`：

```c++
_CRT_SECURITYCRITICAL_ATTRIBUTE
void __CRTDECL operator delete(void* const block) noexcept
{
    #ifdef _DEBUG
    _free_dbg(block, _UNKNOWN_BLOCK);
    #else
    free(block);
    #endif
}
```

调用顺序如下：

```c++
delete pa;
	A::~A();
	operator delete();
		free();
```

总结下来，`new`和`malloc()`的关系如下：

1. `new`是关键字/操作符，而`malloc()`是函数
2. `new`一个对象的时候，不但会分配内存，而且还会调用类的构造函数（当然如果类没有构造函数，系统也没有生成构造函数，那么就无法调用构造函数）
3. 在某些情况下，`A *pa = new A()`能够将对象中的成员变量初始化为0，这也是`new`的能力之一

#### `malloc`做了什么

上面的测试已经很清楚了，`new`最终通过`malloc()`来分配内存，这一点是不可置否的。

那么`malloc`是如何分配内存的？这很复杂（各种链表链来链去，还要合并零散的内存块），可能不同的操作系统有不同的做法。`malloc`可能还需要调用与操作系统有关的更底层的函数来实现内存的分配和管理，`malloc`是跨平台的、通用的函数，但是一旦涉及到系统调用，就不通用了。

#### 总结

一般来说，在C++代码中更偏向使用`new`/`delete`，而非`malloc()`/`free()`。

# `new`内存分配细节探秘与重载类内`operator new/delete`

## `new`内存分配细节探秘

考虑下面三行代码：

```c++
char* ppoint = new char[10];
memset(ppoint, 0, 10);
delete[] ppoint;
```

查看汇编码：

```assembly
main:
        push    rbp
        mov     rbp, rsp
        sub     rsp, 16
        mov     edi, 10
        call    operator new[](unsigned long)
        mov     QWORD PTR [rbp-8], rax			<----- 指针存储的位置
        mov     rax, QWORD PTR [rbp-8]			<----- 调用memset，传入指针
        mov     edx, 10
        mov     esi, 0
        mov     rdi, rax
        call    memset
        cmp     QWORD PTR [rbp-8], 0			<----- 在删除之前先判断是不是空指针
        je      .L2
        mov     rax, QWORD PTR [rbp-8]
        mov     rdi, rax
        call    operator delete[](void*)
.L2:
        mov     eax, 0
        leave
        ret
```

但是需要注意的是，在内存中，当释放内存的时候，往往涉及到合并数据块、登记空闲块的大小、设置空闲块的标记以方便下一次分配等工作。

还有一个问题就是，我们在`delete`的时候并没有告诉编译器要释放多少字节的内存，但是显然编译器肯定知道我们要释放的内存的大小。这部分大小在Visual Studio中更好找到，大概是在被分配的首地址前的12个字节处。

分配内存这件事，假设分配出去的是10个字节，但是这绝不意味着只是简单的10个字节（而是比10字节多很多），在这10字节的周围记录了很多其他内容，比如记录分配出去的字节数等等。

上一节提到过，分配内存最终还是通过`malloc`来进行的。不同的编译器下的`malloc`函数实现各有差异，但是必须的步骤还是有的。通常来说，编译器或者说真正负责内存分配的`malloc`函数可能会分配出这样的内存：

<img src="18_内存高级话题.assets/image-20230101172105463.png" alt="image-20230101172105463" style="zoom: 25%;" />

可以看到，虽然我们只分配了一点点内存，但是编译器处理的时候要分配额外的内存来保存其他信息。不同的编译器可能这里的其他信息项不太一样，但是，编译器位列有效地管理内存的分配和回收，肯定要在分配一块内存之外额外多分配许多空间保存更多的信息。编译器最终返回的是这块大空间中，分配给我们的数据使用的空间的首地址。

最终得到一个结论：分配内存时为了记录和管理分配出去的内存，多分配了许多内存，造成了浪费。尤其是对于频繁分配小块的内存，浪费就显得更加严重。

## 重载类中的`operator new`和`operator delete`操作符

前面提过`new`和`delete`操作符的调用关系：

```c++
A* pa = new A();
	operator new();
		malloc();
	A::A();
```

```c++
delete pa;
	A::~A();
	operator delete();
		free();
```

了解了实现的方式之后，我们就可以实现自己的`operator new`和`operator delete`，我们可以添加一些系统提供的功能中没有的代码，从而获取一些实际的利益。

[1_overload_new_delete.cpp](./测试代码/18_内存高级话题/1_overload_new_delete.cpp)

运行结果：

```
Test::operator new			<----- 调用了我们自己的new
Test::Test
Test::~Test
Test::operator delete		<----- 调用了我们自己的delete
Test::Test
Test::~Test
```

## 重载类中的`operator new []`和`operator delete[]`

[2_overload_new_delete_2.cpp](./测试代码/18_内存高级话题/2_overload_new_delete_2.cpp)

我们分别在`Test::operator new[]`返回指针、以及调用`Test::operator delete[]`的时候观察一下指针的值：

```
Test::operator new []
29		Test* tmp = (Test*)malloc(size);
(gdb) n
30	    return tmp;
(gdb) p size							<----- 传入的size为20
$1 = 20
(gdb) p tmp								
$2 = (Test *) 0x603010					<----- 返回的地址为0x603010
(gdb) c
Breakpoint 2, main () at test.cpp:45
45	  delete[] test1;
(gdb) p test1
$3 = (Test *) 0x603018					<----- delete[]传入的地址为0x603018
(gdb) x/20fb 0x603010
0x603010:	3	0	0	0	0	0	0	0	<----- 0x603010处的字节存了3
0x603018:	0	0	0	0	0	0	0	0
0x603020:	0	0	0	0
```

首先，如果注意程序的运行结果，会发现`operator new[]`和`operator delete[]`只调用了一次，但是构造函数和析构函数调用了多次。

其次，观察gdb的调试结果，在实际的`Test`对象的内存之前，多分配了8个字节，同时，我们`new Test[3]`，每个`Test`对象的大小是4Bytes，所以：
$$
8Bytes + 3 * 4Bytes = 20Bytes = size
$$
同时可以看到，多申请的8个字节的开始存放了对象的个数`3`。

<img src="18_内存高级话题.assets/image-20230102010214522.png" alt="image-20230102010214522" style="zoom:25%;" />

# 内存池概念、代码实现和详细分析

## 内存池的概念和实现原理简介

通过前面的讨论，很容易看出`malloc`在内存分配上的资源浪费，尤其是频繁分配小块内存的时候，浪费更加明显。

因此，“内存池”应运而生。内存池的代码实现千差万别，并且实现有一定的复杂度，但是一些核心的实现思想比较统一。内存池要解决的问题是：

+ 减少`malloc`的调用次数，这意味着减少对内存的浪费
+ 减少对`malloc`的调用次数后，在效率上会有提升，但是不多——`malloc`的效率其实极高

那么，内存池的实现原理是什么？就是用`malloc`申请一大片内存，分配内存的时候，就从这一大块内存中一点点分配给程序员，当一大块内存差不多用完的时候，再申请一大块内存，然后继续分配。

可以看出，内存池对于资源的管理有很高的要求。同时需要注意的是，内存池的出现并不是为了提升程序的效率——这是顺带的，内存池的真正意义是减少内存资源的浪费。

## 针对一个类的内存池实现演示代码

[3_memory_pools.cpp](测试代码/18_内存高级话题/3_memory_pools.cpp)

这段代码值得认真的分析。首先我们来看看`operator new`做了什么事：

1. 第一次调用`operator new`成员函数分配内存的时候，`if`条件是成立的。因此会执行其中的`for`循环语句。整个`if`执行完之后是这个样子的：

   ![](18_内存高级话题.assets/Drawing%202023-01-03%2015.30.44.excalidraw.png)

   代码做的事其实很简单，只是看起来比较绕：在第一次分配的时候，我们一口气分配了五块连续的空间，每一块的大小都是`Test`对象的大小。我们让`_freePos`指向我们分配的第一块空间，然后使用循环将这些空间连起来。

   跳出`if`之后，我们使`_freePos`指向下一个可用的位置，然后将原来可用的位置作为`tmp`返回。

   ![](18_内存高级话题.assets/18_内存高级话题%202023-01-03%2015.38.59.excalidraw.png)

2. 每次`new`一个该类（`Test`）对象，`_freePos`都会指向下一块可以分配的空间，然后返回可以分配的首地址。如果`_freePos`已经指向`nullptr`了，那么就会再一口气分配5块空间，然后循环往复。

***需要注意的是：***`_next`在被分配出去之后就没有任何的意义了。这很好理解，因为`_next`的作用就是在未分配时指向下一块可分配的内存。也就是说，每一个内存块中都有8Bytes（64位机）的内存浪费。这一点我们可以在后面做出修改。

接下来是内存的回收。`operator delete`并不会将内存回收，可以看到我们的代码中并没有调用`free`。我们真正需要做的就是让`_freePos`退回来，指向这块空间，并且将这块空间的`_next`做调整，以方便`_freePos`在分配之后再指向下一块可用的空间。像这样：

<img src="18_内存高级话题.assets/image-20230103161013070.png" alt="image-20230103161013070" style="zoom:25%;" />

代码分析的差不多了，接下来就可以进行测试：

[4_test_memory_pools.cpp](./测试代码/18_内存高级话题/4_test_memory_pool.cpp)

通过测试结果可以看到，时间上确实有一定的效率提升。这段代码其实并没有实现内存回收，本例只是用来展示内存池的基本用法和时间效率的。

如果想要实现内存回收，我们可以使用一个`static vector`来记录大块的被分配内存的入口地址。而为了缩减`vector`中记录的元素造成的内存浪费，我们可以将内存池开的再大一些。

# 嵌入式指针概念说明及范例、内存池改进版

## 嵌入式指针

### 嵌入式指针概念

前面提到，`Test`中的`_next`是无效的，之所以说他是无效的，是因为他只在未分配时用来记录下一块未被分配的内存。

这个问题应当怎样解决？其实问题还是很简单的，众所周知，内存中的数据只有0和1，一个数据被解释为一个char，一个int还是一个指针，完全取决于我们。因此，我们在将内存从内存池中分配之前，完全可以将其中的数据成员解释为指针，并在其中存储`_next`。

于是，这样的指针就被称为嵌入式指针（embedded pointer）。嵌入式指针，很明显，有一个前置条件——一个类对象的大小必须能够放下一个指针，换言之，在64位机下，一个类对象的大小至少应该是8Bytes。

## 内存池代码的改进

在上面的例子中，我们实现内存池的方法是直接在类中假如内存池的代码。但是，显而易见的，内存池应当是一个class wrapper。他应当能够封装各种各样的类，提供内存池的特性。

此处给出一份开源代码：[LiuYuan-SHU](https://github.com/LiuYuan-SHU)/**[MemoryPool](https://github.com/LiuYuan-SHU/MemoryPool)**

我对代码进行了一些修正，例如添加了一个笨拙而实用的makefile，以及修改了`test.cpp`中的一些代码，使其更容易使用。

# 重载全局`new/delete`、定位new及重载

## 重载全局`operator new`和`operator delete`操作符

[5_overload_global_new_delete.cpp](./测试代码/18_内存高级话题/5_overload_global_new_delete.cpp)

当然，这样的做法是很不好的，因为这样的影响面太大。通常只需要重载类内的函数即可。

如果类内又重改了这两个运算符，就会覆盖掉全局的调用方法。

## 定位`new`(placement new)

前面提到的`new`都是传统意义上的`new`。除了传统意义上的`new`，还有一种`new`叫做"定位`new`"。由于用法比较特别，因此并没有对应的placement delete的说法。

首先需要明确定位`new`与普通`new`的层级关系。它们位于同一个层次，但是定位`new`的功能是：在**已经分配**的原始内存中初始化一个对象。这句话有两个关键点：

+ 已经分配：意味着定位`new`并不分配内存，也就是使用定位`new`之前内存必须已经被分配好
+ 初始化一个对象：也就是初始化对象的内存，可以理解为调用其构造函数

总而言之，***定位`new`用于在一个预先分配好的内存地址中构造一个对象***

定位`new`的格式如下：

```c++
new(ptr) type(variables...);

extern class Test;
void* mymemPoint = (void*)new char[sizeof(Test)];
Test* pTest = new(mymemPoint) Test();
```

## 多种版本的`operator new`重载

其实我们可以重载很多版本的`operator new`，只需要他们的参数不同就行。第一个参数固定，类型是`size_t`，表示这个对象的`sizeof`值。同时，这个值也不需要我们传入，就像成员函数的`this`指针一样。其它参数通过调用`new`的时候传进去即可。

[Test code](./测试代码/18_内存高级话题/6_multi_version_new.cpp)

在我的测试代码中，并没有重载`operator delete`，但是有的时候可能也会报错表示未找到匹配的删除运算符，这个时候就重载`operator delete(void* phead, int val1, int val2)`即可。

另外注意，***这种`new`的用法并不会去调用构造函数。所以，这个重载的`operator new`中做什么，完全取决于程序员。***

## 总结

介绍`placement new`和多版本`operator new`并不是鼓励这样使用，只是在需要的时候再用（比如对于自定义的memory pool的实现，`placement new`就有其优越性），或者是方便阅读他人的代码。

