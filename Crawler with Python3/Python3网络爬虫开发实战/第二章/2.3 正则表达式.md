```toc
```

> [正则表达式测试工具 - 开源中国](http://tool.oschina.net/regex)

# 示例引入

## 常用的匹配规则

|   模式   | 描述                                                                                       |
|:--------:| ------------------------------------------------------------------------------------------ |
|   `\w`   | 匹配字母、数字及下划线                                                                     |
|   `\W`   | 匹配不是字母、数字以及下划线的字符                                                         |
|   `\s`   | 匹配任意空白字符，等价于`[\t\n\r\f]`                                                       |
|   `\S`   | 匹配任意非空字符                                                                           |
|   `\d`   | 匹配任意数字，等价于`[0-9]`                                                                |
|   `\D`   | 匹配任意非数字字符                                                                         |
|   `\A`   | 匹配字符串开头                                                                             |
|   `\Z`   | 匹配字符串结尾。如果存在换行，只匹配到换行前的结束字符串                                   |
|   `\z`   | 匹配字符串结尾。如果存在换行，同时还会匹配换行符。                                         |
|   `\G`   | 匹配最后匹配完成的位置                                                                     |
|   `\n`   | 匹配一个换行符                                                                             |
|   `\t`   | 匹配一个制表符                                                                             |
|   `^`    | 匹配一行字符串的开头                                                                       |
|   `$`    | 匹配一行字符串的结尾                                                                       |
|   `.`    | 匹配任意字符，除了换行符。</br>当`re.DOTALL`标记被指定时，可以匹配包括换行符在内的任意字符 |
| `[...]`  | 用来表示一组字符，单独列出，例如`[amk]`用来匹配a、m或k                                     |
| `[^...]` | 匹配不在`[]`中的字符                                                                       |
|   `*`    | 匹配0个或多个表达式                                                                        |
|   `+`    | 匹配1个或多个表达式                                                                        |
|   `?`    | 匹配0个或1个前面的正则表达式定义的片段，非贪婪方式                                         |
|  `{n}`   | 精确匹配`n`个前面的表达式                                                                  |
| `{n,m}`  | 匹配`n`到`m`次由前面正则表达式定义的片段，贪婪方式                                         |
|  `a丨b`   | 匹配`a`或`b`                                                                               |
| `()`         | 匹配括号内的表达式，也表示一个组                                                                                           |
## [`match`](https://github.com/LiuYuan-SHU/MyNotes/blob/de262a234871b25f034c23f5c3ddcd141e68e59a/Crawler%20with%20Python3/Python3%20web%20crawler%20development%20practice%EF%BC%88Edition2%EF%BC%89%20-%20Cui%20Qingcai/2_use_of_basic_libraries/2.3/2.3.1_match.py)

`match`方法会尝试从字符串的起始位置开始匹配正则表达式，如果匹配，就返回匹配成功的结果；如果不匹配，就返回`None`。

将输入结果打印出来，可以看到结果是`SRE_Match`对象，证明匹配成功。该对象包含两个方法：

1. `group`方法可以输出匹配到的内容
2. `span`方法可以输出匹配的范围，代表匹配到的结果字符串在原字符串中的位置范围

## [匹配目标](https://github.com/LiuYuan-SHU/MyNotes/blob/7660322235b188ff8c39154e7f4168c9308e0e6d/Crawler%20with%20Python3/Python3%20web%20crawler%20development%20practice%EF%BC%88Edition2%EF%BC%89%20-%20Cui%20Qingcai/2_use_of_basic_libraries/2.3/2.3.2_%E5%8C%B9%E9%85%8D%E7%9B%AE%E6%A0%87.py)

用`match`方法可以实现匹配，如果想从字符串中提取一部分内容，我们可以使用`()`将想要的内容括起来。`()`实际上标记了一个子表达式的开始和结束位置，被标记的每个子表达式一次对应每个分组，调用`group`方法传入分组的索引即可获取提取结果。

## 通用匹配

刚才我们编写的正则表达式其实比较复杂：只要出现空白字符就需要写`\s`，只要出现数字就需要`\d`匹配，这样的工作量非常大。我们可以使用`.*`来匹配任意字符（除了换行符）。

## [贪婪与非贪婪](https://github.com/LiuYuan-SHU/MyNotes/blob/e8cdaa88a14c330490ff86aec0932221f64a9df4/Crawler%20with%20Python3/Python3%20web%20crawler%20development%20practice%EF%BC%88Edition2%EF%BC%89%20-%20Cui%20Qingcai/2_use_of_basic_libraries/2.3/2.3.3_%E8%B4%AA%E5%A9%AA%E4%B8%8E%E9%9D%9E%E8%B4%AA%E5%A9%AA.py)

使用通用匹配`.*`获得的内容有的时候不是我们想要的结果。

### 函数`greedy`

在贪婪匹配下，`.*`会匹配尽可能多的字符。正则表达式中`.*`后面是`\d+`，也就是只杀一个数字，而且没有指定具体几个数字。因此，`.*`就会匹配尽可能多的字符，从而只留一个数字给`\d+`。

这很明显会给我们带来很大的额不变。有的时候，匹配的结果会莫名其妙少一部分内容。这时，我们就需要非贪婪匹配。

### 函数`not_greedy`

我们将`.*`换成`.*?`就可以转换为非贪婪匹配。非贪婪匹配的思路是匹配尽量少的字符。当`.*?`匹配到`Hello`后面的空白字符的时候，再往后的字符就是数字了，交给`\d+`来说正合适。

### 函数`str_end`

但是需要注意的是，如果匹配的结果在字符串结尾，`.*?`有可能匹配不到任何内容，因为它会匹配尽可能少的字符。

## 修饰符



