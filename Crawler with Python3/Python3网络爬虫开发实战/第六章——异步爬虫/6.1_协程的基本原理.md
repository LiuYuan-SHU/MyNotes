# 1. 案例引入

平时我们浏览网页的时候，绝大部分网页的响应速度还是很快的，如果写爬虫来爬取，那么从发出请求到接受响应的时间不会很长，因此需要我们等待的时间并不多。

但是对于一些响应较慢的网站来说，花费的时间就要很多。如果我们使用`requests`单程来做，总耗时将会非常大。此时如果要是打开多进程或是多线程来爬取，效果就会好很多。

# 2. 基础知识

## 阻塞

**阻塞状态指程序未得到所需计算资源时被挂起的状态**。程序在等待某个操作完成的期间，自身无法继续干别的事情，则称该程序在该操作上是阻塞的。

常见形式的阻塞形式有：网络IO阻塞、磁盘IO阻塞、用户输入阻塞等。阻塞是无处不在的，包括在CPU切换上下文的时候，所有进程都无法真正干事情，他们也会被阻塞。在多核CPU的情况下，正在执行上下文切换操作的核不可被利用。

## 非阻塞

程序在等待某操作的过程中，自身不被阻塞，可以继续干别的事情，则称该程序在该操作上是非阻塞的。非阻塞并不是在任何程序级别、任何情况下都存在的。仅当程序封装的级别可以囊括独立的子程序单元时，程序才可能存在非阻塞状态。

非阻塞因阻塞的存在而存在，正因为阻塞导致程序运行的耗时增加与效率低下。我们才要把它变成非阻塞的。

## 同步

不同程序单元为了共同完成某个任务，在执行过程中需要通过某种通信方式来保持协调一致，此时这些程序单元是可以同步执行的。

例如在购物系统中更新商品库存时，需要用“行锁”作为通信信号，强制让不同的更新请求排队并按顺序执行，这里的更新库存操作就是同步的。

简而言之，同步意味着有序。

## 异步

为了完成某个任务，有时不同程序单元之间无须通信协调也能完成任务，此时不相关的程序单元之间可以是异步的。

例如，爬取下载网页。调度程序调用下载程序后，即可调度其他任务，无须与该下载任务保持通信以协调行为。不同网页的下载、保存等操作都是无关的，也无须相互通知协调。这些一步操作的完成时刻并不确定。

简言之，异步意味着无序。

## 多进程

多进程就是利用CPU的多核优势，在同一时间并行执行多个任务，可以大大提高执行效率。

## 协程

协程，英文叫作coroutine，又称微线程、纤程，是一种运行在用户态的轻量级线程。

协程拥有自己的寄存器上下文和栈。协程在调度切换的时候，将寄存器上下文和栈保存到其他地方，等切回来的时候，再恢复先前保存的寄存器上下文和栈。因此，协程能保留上一次调用时的状态，即所有局部状态的一个特定组合，每次过程重入，就相当于进入上一次调用的状态。

协程本质上是单进程，相对于多进程来说，它没有线程上下文切换的开销，没有原子操作锁定及同步的开销，编程模型也非常简单。

我们可以使用协程来实现异步操作，例如在网络爬虫场景下，我们发出一个请求之后，需要等待一定时间才能得到相应，但其实在这个等待过程中，看程序可以干许多其他事情，等得到相应之后再切换回来继续处理，这样可以充分利用CPU和其他资源，这就是协程的优势。

# 3. 协程的用法

* `event_loop`：事件循环，相当于一个无限循环，我们可以把一些函数注册到这个事件循环上，当满足发生条件的时候，就调用对应的方法
* `coroutine`：协程，在Python中常代指协程对象类型，我们可以将写成对象注册到事件循环中，它会被事件循环调用。我们可以使用`async`关键字来定义一个方法，这个方法在调用时不会立即被执行，而是会返回一个协程对象
* `task`：任务，这是对协程对象的进一步封装，包含协程对象的各个状态
* `future`：代表将来执行或者没有执行的任务的结果，实际上和`task`没有本质上的区别
* `async`：定义一个协程
* `await`：挂起阻塞方法的执行

# 5. 定义协程

