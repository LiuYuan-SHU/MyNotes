# 第一章 代码背后

[TOC]

## 从编程聊起

```mermaid
flowchart LR;
source[source code] --compiler--> assembly --assembler--> bin[binary object files] --linker--> executable
```

## 历史渊源

1. 手写机器码

2. 打孔纸带

3. 汇编语言: 汇编器产生

    ```mermaid
    flowchart LR;
    subgraph 存在的问题
    	duplicate[存在大量重复代码]
    end
    
    存在的问题 --> 解决方法
    
    subgraph 解决方法
    	提取公共代码 --> 
    	汇编成独立的模块存储在目标文件中 --> 
    	将同类文件打包成库
    end
    
    解决方法 --> 新的问题
    
    subgraph 新的问题
    	将多个分离的文件拼装起来,形成完整的代码 --> 
    	符号相互引用 --> 
    	重新计算符号的引用地址
    end
    
    新的问题 --解决方法--> 链接器
    ```

4. 链接器

    ```mermaid
    flowchart TD;
    
    subgraph 静态链接
    	object(目标文件) & static(静态库) --> 
    	linker[链接器] --> 
    	exec(可执行文件)
    end
    
    subgraph 动态链接
    	object1(目标文件) & dynamic(动态库) -->
    	链接器 -->
    	可执行文件 -.依赖.-> object1
    end
    ```

    1. 静态链接: 静态链接把公用库内的目标文件合并到可执行文件内部, 使得可执行文件的体积变得庞大. 这样做会导致可执行文件版本难以更新, 也导致了多个程序加载后相同的公用代码占用了多份内存空间.
    2. 动态链接: 动态链接不会把公用库内的目标文件合并到可执行文件内, 而仅仅记录动态链接库的路径信息. 它允许程序运行前才加载所需的动态链接库, 如果该动态链接库已经加载到内存, 则不需要重复加载. 另外, 动态链接器也允许将动态链接库的加载延迟到执行库函数调用的那一刻. 这样做不仅解约了磁盘和内存空间, 还方便了可执行文件版本的更新. 如果应用程序模块设计合理的话, 程序更新时只需要更新模块对应的动态链接库即可.
        1. 缺点: 
            1. 运行时链接的方式会增加程序执行的时间开销.
            2. 动态链接库的版本错误可能会导致程序无法运行

## GCC 的工作流程

测试代码:

```cpp
#include <stdio.h>

int main() {
    printf("Hello World!");
    
    return 0;
}
```

在 X86 Linux 下运行:

```shell
gcc hello.c -o hello --static --verbose
```

输出的结果很多, 我们需要的部分	:

```
 /usr/lib/gcc/x86_64-linux-gnu/9/cc1 -quiet -v -imultiarch x86_64-linux-gnu hello.c -quiet -dumpbase hello.c -mtune=generic -march=x86-64 -auxbase hello -version -fasynchronous-unwind-tables -fstack-protector-strong -Wformat -Wformat-security -fstack-clash-protection -fcf-protection -o /tmp/ccoLPDAt.s

 as -v --64 -o /tmp/cc4GyEUs.o /tmp/ccoLPDAt.s

 /usr/lib/gcc/x86_64-linux-gnu/9/collect2 -plugin /usr/lib/gcc/x86_64-linux-gnu/9/liblto_plugin.so -plugin-opt=/usr/lib/gcc/x86_64-linux-gnu/9/lto-wrapper -plugin-opt=-fresolution=/tmp/cc6f7phs.res -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_eh -plugin-opt=-pass-through=-lc --build-id -m elf_x86_64 --hash-style=gnu --as-needed -static -z relro -o hello /usr/lib/gcc/x86_64-linux-gnu/9/../../../x86_64-linux-gnu/crt1.o /usr/lib/gcc/x86_64-linux-gnu/9/../../../x86_64-linux-gnu/crti.o /usr/lib/gcc/x86_64-linux-gnu/9/crtbeginT.o -L/usr/lib/gcc/x86_64-linux-gnu/9 -L/usr/lib/gcc/x86_64-linux-gnu/9/../../../x86_64-linux-gnu -L/usr/lib/gcc/x86_64-linux-gnu/9/../../../../lib -L/lib/x86_64-linux-gnu -L/lib/../lib -L/usr/lib/x86_64-linux-gnu -L/usr/lib/../lib -L/usr/lib/gcc/x86_64-linux-gnu/9/../../.. /tmp/cc4GyEUs.o --start-group -lgcc -lgcc_eh -lc --end-group /usr/lib/gcc/x86_64-linux-gnu/9/crtend.o /usr/lib/gcc/x86_64-linux-gnu/9/../../../x86_64-linux-gnu/crtn.o
```

上面运行了三条指令:

1. `cc1`: GCC 的编译器, 它将源文件`hello.c`编译为`/tmp/ccoLPDAt.s`

2. `as`是汇编器命令, 它将临时汇编文件汇编为`/tmp/cc4GyEUs.o`

3. `colletc2`是链接器命令, 它是对命令`ld`的封装. 

    对命令进行精简, `colletc2`链接了:

    1. `crt1.o`
    2. `crti.o`
    3. `crtbeginT.o`
    4. `/tmp/cc4GyEUs.o`
    5. `crtend.o`
    6. `crtn.o`

    除了 4 是汇编其产生的目标文件, 其他的目标文件都是 C 运行时库(CRT, C runtime).

    实际上, 还连接了静态库:

    1. `libgcc.a`
    2. `libhcc_eh.a`
    3. `libc.a`

### 预编译

GCC 对源文件的第一阶段的处理是预编译, 主要是处理宏定义和文件包含等信息. 命令格式如下:

```shell
gcc -E hello.c -o hello.i
```

预处理器将`hello.c`处理后输出到文件`hello.i`, `hello.i`文件内容如下:

```assembly
# 1 "hello.c"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "hello.c"
# ......
extern int printf (const char *__restrict __format, ...);
# ......
int main() {
    printf("Hello World!");

    return 0;
}
```

比如文件包含语句`#include <stdio.h>`, 预编译器会将`stdio.h`的文件内容拷贝到`#include`语句生命的位置. 如果源文件内使用了`#define`语句是定义了宏, 预编译器则会将该宏的内容替换到其被引用的位置. 如果宏定义本身也使用了其他宏, 则编译器需要将宏递归地展开. 

### 编译

```shell
gcc -S hello.i -o hello.s
```

输出:

```assembly
.file	"hello.c"
	.text
	.section	.rodata
.LC0:
	.string	"Hello World!"		# <-------------------------------------------
	.text
	.globl	main
	.type	main, @function
main:	# <-------------------------------------------
.LFB0:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	leaq	.LC0(%rip), %rax
	movq	%rax, %rdi
	movl	$0, %eax
	call	printf@PLT	# <-------------------------------------------
	movl	$0, %eax
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc
.LFE0:
	.size	main, .-main
	.ident	"GCC: (Ubuntu 11.3.0-1ubuntu1~22.04.1) 11.3.0"
	.section	.note.GNU-stack,"",@progbits
	.section	.note.gnu.property,"a"
	.align 8
	.long	1f - 0f
	.long	4f - 1f
	.long	5
0:
	.string	"GNU"
1:
	.align 8
	.long	0xc0000002
	.long	3f - 2f
2:
	.long	0x3
3:
	.align 8
4:
```

GCC 生成的汇编代码的语法是 AT&T 格式, 与 Intel 格式的汇编有所不同(若要生成 Intel 格式的汇编代码, 可以使用编译选项`-masm=intel`)

### 汇编

```shell
gcc -c hello.s -o hello.o
```

生成的目标文件`hello.o`, Linux 下称之为可重定位目标文件. 目标文件无法使用文本编辑器直接查看, 但是我们可以使用 GCC 自带的工具 `objdump`命令分析它的内容:

```shell
objdump -sd hello.o
```

其中, `s`选项指的是全文本翻译, `d`选项指的是反汇编

```
hello.o:     file format elf64-x86-64

Contents of section .text:
 0000 f30f1efa 554889e5 488d0500 00000048  ....UH..H......H
 0010 89c7b800 000000e8 00000000 b8000000  ................
 0020 005dc3                               .].
Contents of section .rodata:
 0000 48656c6c 6f20576f 726c6421 00        Hello World!.
Contents of section .comment:
 0000 00474343 3a202855 62756e74 75203131  .GCC: (Ubuntu 11
 0010 2e332e30 2d317562 756e7475 317e3232  .3.0-1ubuntu1~22
 0020 2e30342e 31292031 312e332e 3000      .04.1) 11.3.0.
Contents of section .note.gnu.property:
 0000 04000000 10000000 05000000 474e5500  ............GNU.
 0010 020000c0 04000000 03000000 00000000  ................
Contents of section .eh_frame:
 0000 14000000 00000000 017a5200 01781001  .........zR..x..
 0010 1b0c0708 90010000 1c000000 1c000000  ................
 0020 00000000 23000000 00450e10 8602430d  ....#....E....C.
 0030 065a0c07 08000000                    .Z......

Disassembly of section .text:

0000000000000000 <main>:
   0:	f3 0f 1e fa          	endbr64
   4:	55                   	push   %rbp
   5:	48 89 e5             	mov    %rsp,%rbp
   8:	48 8d 05 00 00 00 00 	lea    0x0(%rip),%rax        # f <main+0xf>
   f:	48 89 c7             	mov    %rax,%rdi
  12:	b8 00 00 00 00       	mov    $0x0,%eax
  17:	e8 00 00 00 00       	call   1c <main+0x1c>
  1c:	b8 00 00 00 00       	mov    $0x0,%eax
  21:	5d                   	pop    %rbp
  22:	c3                   	ret
```

可以看到基本吻合, 但是字符串`Hello World!`的地址变为了`0x0`, 同时`printf`的调用语句中, 相对地址变为了`00 00 00 00`. 这些区别本质来源于汇编语言符号的引用问题. 由于汇编器在处理当前文件的过程中无法获悉符号的虚拟地址, 因此临时将这些符号地址值设为 `0`. 真正的符号地址只有在链接的时候才能确定.

### 链接

```shell
gcc hello.o -o hello
```

GCC 默认使用动态链接, 可以加上`-static`使用静态链接.

使用`objdump`依然可以查看可执行文件的内容, 此处仅展示`main`的代码:

```
0000000000401745 <main>:
  401745:       f3 0f 1e fa             endbr64
  401749:       55                      push   %rbp
  40174a:       48 89 e5                mov    %rsp,%rbp
  40174d:       48 8d 05 b0 68 09 00    lea    0x968b0(%rip),%rax        # 498004 <_IO_stdin_used+0x4>
  401754:       48 89 c7                mov    %rax,%rdi
  401757:       b8 00 00 00 00          mov    $0x0,%eax
  40175c:       e8 2f 9e 00 00          call   40b590 <_IO_printf>
  401761:       b8 00 00 00 00          mov    $0x0,%eax
  401766:       5d                      pop    %rbp
  401767:       c3                      ret
  401768:       0f 1f 84 00 00 00 00    nopl   0x0(%rax,%rax,1)
  40176f:       00
```

1. `endbr64`: 用于启用x86-64的分支目标识别。它在某些情况下用于提高分支预测的精度
2. `lea    0x968b0(%rip),%rax`: 将字符串的地址载入
3. `_IO_printf`与`printf`完全等价
4. 最后两行: 填充指令流, 用于对齐指令

