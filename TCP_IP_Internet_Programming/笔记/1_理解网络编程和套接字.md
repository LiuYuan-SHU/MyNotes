[TOC]

# 理解网络编程和套接字

## 网络编程和套接字概要

1. 网络编程就是编写程序使两台联网的计算机相互交换数据。

2. 两台计算机之间使用什么传输数据？
    + 物理连接
    + 软件设备：Socket

## 构建接电话套接字

如何接电话？

+ 准备电话机
+ 分配电话号码
+ 连接电话线
+ 拿起电话接听电话

**网络编程中接受连接请求的套接字创建过程可整理如下：**

1. 调用`socket`函数创建套接字
2. 调用`bind`函数分配IP地址和端口号
3. 调用`listen`函数转为可接收请求状态
4. 调用`accept`函数受理连接请求

### 使用`socket`函数创建套接字

```cpp
#include <sys/socket.h>
// 成功时返回文件描述符，失败时返回-1
int socket(int domain, int type, int protocol);
```

### 使用`bind`函数分配IP地址和端口号

```cpp
#include <sys/socket.h>
// 成功时返回0，失败时返回-1
int bind(int sockfd, struct sockaddr * myaddr, socklen_t addrlen);
```

### 调用`listen`将套接字转化成可接收连接状态

```cpp
#include <sys/socket.h>
// 成功时返回0，失败时返回-1
int listen(int sockfd, int backlog);
```

### 使用`accept`函数接受请求

```cpp
#include <sys/socket.h>
// 成功时返回文件描述符，失败时返回-1
int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
```

## 编写`Hello World!`服务器端

服务器端（server）是能够受理连接请求的程序。下面构建服务器端以验证之前提到的函数调用过程，该服务器收到连接请求后向请求者返回`Hello World!`答复。

***[示例程序：hello_server.c](../示例代码/hello_server.c)***

```cpp
#include <netinet/in.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/_endian.h>
#include <sys/_types/_socklen_t.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>

void error_handling(char* message);

int main(int argc, char* argv[])
{
	int serv_sock;
	int clnt_sock;

	struct sockaddr_in serv_addr;
	struct sockaddr_in clnt_addr;
	socklen_t clnt_addr_size;

	char message[] = "Hello World!";

	if (argc != 2)
	{
		printf("Usage : %s <port> \n", argv[0]);
		exit(1);
	}

	// 调用Socket函数创建套接字
	serv_sock = socket(PF_INET, SOCK_STREAM, 0);
	if (serv_sock == -1)
	{
		error_handling("socket() error");
	}

	memset(&serv_addr, 0, sizeof(serv_addr));
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);
	serv_addr.sin_port = htons(atoi(argv[1]));

	// 调用bind分配IP地址和端口号
	if (bind(serv_sock, (struct sockaddr*) &serv_addr, sizeof(serv_addr)) == -1)
	{
		error_handling("bind() error");
	}

	// 调用listen函数将套接字转为可接收状态
	if (listen(serv_sock, 5) == -1)
	{
		error_handling("listen() error");
	}

	clnt_addr_size = sizeof(clnt_addr);
	// 调用accept函数受理连接请求
	// 如果在没有连接请求的情况下调用该函数，则不会返回，直到有连接请求为止
	clnt_sock = accept(serv_sock, (struct sockaddr*) &clnt_addr, &clnt_addr_size);
	if (clnt_sock == -1)
	{
		error_handling("accept() error");
	}

	// 用于传输数据
	write(clnt_sock, message, sizeof(message));
	close(clnt_sock);
	close(serv_sock);
	return 0;
}

void error_handling(char* message)
{
	fputs(message, stderr);
	fputc('\n', stderr);
	exit(1);
}
```

可以在代码所在文件夹下运行`make hello_server`，然后使用`./hello_server 5005`，将程序运行在5005端口

## 创建发送请求的套接字

服务器创建的套接字又称为服务器端套接字或监听（listening）套接字。客户端套接字是用于请求的套接字，其使用到了`connect`函数：

```cpp
#include <sys/socket.h>
// 成功时返回0，失败时返回-1
int connect(int sockfd, struct sockaddr *serv_addr, socklen_t addrlen);
```

客户端程序只有“调用Socket函数创建套接字”和“调用`connect`函数向服务端发送链接请求”这两个步骤，因此比服务器端简单。

***[示例程序：hello_client.c](../示例代码/hello_client.c)***
```cpp
#include <netinet/in.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/_endian.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>

void error_handling(char* message);

int main(int argc, char* argv[])
{
	int sock;
	struct sockaddr_in serv_addr;
	char message[30];
	int str_len;

	if (argc != 3)
	{
		printf("Usage : %s <IP> <port>\n", argv[0]);
		exit(1);
	}

	// 创建套接字，但此时套接字并不马上分为服务器端和客户端。
	// 如果紧接着调用`bind`, `listen`函数，将肠胃服务器端套接字
	// 如果调用`connect`函数，将成为客户端套接字
	sock = socket(PF_INET, SOCK_STREAM, 0);
	if (sock == -1)
	{
		error_handling("socket() error");
	}

	memset(&serv_addr, 0, sizeof(serv_addr));
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = inet_addr(argv[1]);
	serv_addr.sin_port = htons(atoi(argv[2]));

	// 调用`connect`函数向服务器端发送连接请求
	if (connect(sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) == -1)
	{
		error_handling("connect() error");
	}

	str_len = read(sock, message, sizeof(message) - 1);
	if (str_len == -1)
	{
		error_handling("read() error");
	}

	printf("Message from server : %s \n", message);
	close(sock);
	return 0;
}

void error_handling(char* message)
{
	fputs(message, stderr);
	fputc('\n', stderr);
	exit(1);
}
```

可以在代码所在文件夹下运行`make hello_client`， 然后使用`./hello_client 127.0.0.1 5005`来请求服务端。但是需要注意，在启动客户端之前需要先启动服务端。

当然，也可以直接`make hello`来一次编译所有程序

# 基于Linux的文件操作

> 讨论Socket的过程中突然谈及文件也许有些奇怪。但对Linux而言，Socket操作与文件操作没有区别，因而有必要详细了解文件。在Linux世界里，Socket也被认为是文件的一种，因此在网络数据传输过程中自然可以使用文件IO相关的函数。Windows则与Linux不同，是要区分Socket和文件的，因此在Windows中需要调用特殊的数据传输相关函数。

## 底层文件访问（Low-Level File Access）和文件描述符（File Descriptor）

“底层”的含义是指“与标准无关的操作系统独立提供的”。接下来的函数是由Linux提供的，而非ANSI标准定义的函数。如果想使用Linux提供的文件IO函数，首先应该理解好文件描述符的概念。

此处的文件描述符是系统分配给文件或套接字的整数。实际上，标准输入输出以及标准错误在Linux中也被分配下列的文件描述符：

| 文件描述符 | 对象 |
| :--:|:--:|
| 0 | 标准输入：Standard Input |
| 1 | 标准输出：Standard Output |
| 2 | 标准错误：Standard Error |

文件和套接字一般经过创建过程才会被分配文件描述符。而上表中的三个输入输出对象即使没有经过特殊的创建过程，程序开始运行后也会被自动分配文件描述符。

> 每当生成文件或套接字，操作系统将返回分配给它们的整数。这个整数将成为程序员与操作系统之间良好沟通的渠道。实际上，文件描述符只不过是为了方便称呼操作系统创建的文件或套接字而赋予的数而已。
>
> 文件描述符有时也成为文件句柄，而句柄主要是Windows中的术语。

## 打开文件

> [***`open`与`fopen`的区别***](https://blog.csdn.net/weixin_47731862/article/details/112273651)

首先介绍打开文件以及读写文件的函数。调用此函数时需要传递两个参数：第一个参数是打开的目标文件名以及路径信息，第二个参数是文件打开模式（文件特性信息）。

```cpp
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

// 成功时返回文件描述符，失败时返回-1
int open(const char* *path, int flag);
```

| 打开模式 | 含义                       |
| -------- | -------------------------- |
| O_CREAT  | 必要时创建文件             |
| O_TRUNC  | 删除全部现有数据           |
| O_APPEND | 维持现有数据，保存到其后面 |
| O_RDONLY | 只读打开                   |
| O_WRONLY | 只写打开                   |
| O_RDWR   | 读写打开                   |

## 关闭文件

```c
#include <unistd.h>

// 成功时返回0，失败时返回-1
// fd：需要关闭的文件或套接字的文件描述符
int close(int fd);
```

需要注意的是，此函数不仅可以关闭文件，还可以关闭套接字，这再次证明了***Linux操作系统不区分文件与套接字***的特点。

## 将数据写入文件

`write`函数用于向文件输出（传输）数据。当然，Linux不区分文件与套接字，因此，通过套接字向其他计算机传递数据时也会用到该函数。

```c
#include <unistd.h>

// 成功时返回写入的字节数，失败时返回-1
// fd：显示数据传输对象的文件描述符
// buf：保存要传输数据的缓冲地址值
// nbytes：要传输数据的字节数
ssize_t write(int fd, const void* buf, size_t nbytes);
```

此函数定义中，`size_t`是通过`typedef`声明的`unsigned int`类型。对`ssize_t`来说，`size_t`前面多加的s代表`signed`，即`ssize_t`使通过`typedef`定义的`signed int`类型。

> 我们已经接触到`ssize_t`，`size_t`等陌生的数据类型。这些都是元数据类型（primitive），在`sys/types.h`头文件中一般由`typedef`定义，算是给熟悉的基本数据类型起了别名。既然已经有了基本数据类型，为何还要声明并使用这些新的呢？
>
> 人们目前普遍认为`int`是32位的，因为主流操作系统和计算机仍采用32位。而在过去16位操作系统时代，`int`类型是16位的。根据操作系统的不同、时代的变化，数据类型的表现形式也随之改变，需要修改程序中使用的数据类型。如果之前已在需要声明4字节数据类型支出使用了`size_t`或`ssize_t`，则大大减少了代码变动，因为只需要修改并编译`size_t`和`ssize_t`的`typedef`声明即可。在项目中，为了给基本数据类型赋予别名，一般会添加大量`typedef`声明。而为了与程序员定义的新数据类型加以区分，操作系统定义的数据类型会添加后缀`_t`。

***[示例程序：low_write.c](../示例代码/low_write.c)***

```c
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/fcntl.h>
#include <unistd.h>

void error_handling(char* message);

int main()
{
	int fd;
	char buf[] = "Let's go!\n";

	fd = open("data.txt", O_CREAT | O_WRONLY | O_TRUNC);
	if (fd == -1)
	{
		error_handling("open() error");
	}

	printf("file descriptor: %d \n", fd);

	if (write(fd, buf, sizeof(buf)) == -1)
	{
		error_handling("write() error");
	}
	close(fd);

	return 0;
}

void error_handling(char* message)
{
	fputs(message, stderr);
	fputc('\n', stderr);
	exit(1);
}
```

## 读取文件中的数据

```c
#include <unistd.h>

// 成功时返回接收的字节数（但遇到文件结尾则返回0），失败时返回-1
/*
 * fd：显示数据接收对象的文件描述符
 * buf：要保存接收数据的缓冲地址值
 * nbytes：要接受数据的最大字节数
 */
ssize_t read(int fd, void* buf, size_t nbytes);
```

***[示例程序：low_read.c](../示例代码/hello_read.c)***

```c
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

#define BUF_SIZE 100

void error_handling(char* message);

int main()
{
	int fd;
	char buf[BUF_SIZE];

	fd = open("data.txt", O_RDONLY);
	if (fd == -1)
	{
		error_handling("open() error");
	}
	printf("file descriptor : %d\n", fd);
	
	if (read(fd, buf, sizeof(buf)) == -1)
	{
		error_handling("read() error");
	}
	printf("file data: %s", buf);
	close(fd);

	return 0;
}

void error_handling(char* message)
{
	fputs(message, stderr);
	fputc('\n', stderr);
	exit(1);
}
```

## 文件描述符与套接字

# 基于Windows平台的实现

