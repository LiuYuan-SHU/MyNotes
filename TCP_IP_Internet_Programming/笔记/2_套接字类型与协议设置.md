[TOC]

# 套接字协议及其数据传输特性

## 关于协议（protocol）

协议就是为了完成数据交换而定好的约定。

## 创建套接字

```c
#include <sys/socket.h>

// 成功时返回文件描述符，失败时返回-1
/*
 * domain：套接字中使用的协议族（protocol family）信息
 * type：套接字数据传输类型信息
 * protocol：计算机通信中使用的协议信息
 */
int socket(int domain, int type, int protocol);
```

### 协议族（Protocol Family）

奶油意大利面和番茄酱意大利面均属于意大利面的一种，与之类似的，套接字通信中的协议也具有一些分类。通过Socket函数的第一个参数传递我们想要使用的协议分类信息。此协议分类信息成为协议族

| 名称      | 协议族               |
| --------- | -------------------- |
| PF_INET   | IPv4互联网协议族     |
| PF_INET6  | IPv6互联网协议族     |
| PF_LOCAL  | 本地通信的UNIX协议族 |
| PF_PACKET | 底层套接字的协议族   |
| PF_IPX    | IPX Novell协议族     |

套接字中实际采用的最终协议信息是通过Socket函数的第三个参数传递的。在指定的协议族范围内通过第一个参数决定第三个参数。

### 套接字类型（Type）

套接字类型指的是套接字的数据传输方式，通过Socket函数的第二个参数传递，只有这样才能决定创建的套接字的数据传输方式。这样的说法可能会产生一些疑惑：已经通过第一个参数传递了协议族信息，为什么还要决定数据传输方式？问题就在于，决定了协议族并不能同时决定数据传输方式，换言之，socket函数第一个参数`PF_INET`协议族中也存在多种数据传输方式。

#### 面向连接的套接字——`SOCK_STREAM`

> 可靠的、按序传递的、基于字节的面向连接的数据传输方式的套接字。

面向连接的套接字的特征如下：

+ 传输过程中数据不会消失
+ 按序传输数据
+ 传输的数据不存在数据边界（Boundary）
+ 套接字必须一一对应

只要传输线路本身没有问题，就能保证数据不丢失。同时，较晚传递的数据不会先到达，因为传送方式保证了数据的按序传递。同时，下面这句话可以说明数据没有数据边界：

>  ***“传输数据的计算机通过3次调用`write`函数传递了100字节的数据，但接收数据的计算机仅通过一次`read`函数调用就接收了全部100个字节”***

收发数据的套接字内部有缓冲（buffer），简而言之就是字节数组。通过套接字传输的数据将保存到该数组。因此，收到数据并不意味着马上调用`read`函数。只要不超过数组容量，则有可能在数据填充满缓冲后通过1次`read`函数调用读取全部，也有可能分成多次`read`函数调用进行读取。也就是说，***在面向连接的套接字中，`read`函数和`write`函数的调用次数并不太多意义。***

> ###### ***套接字缓冲已满是否意味着数据丢失？***
>
> 前文提到，为了接收数据，套接字内部有一个由字节数组构成的缓冲。如果这个缓冲被接受的数据填满了会发生什么？之后传递的数据是否会丢失？
>
> 首先调用`read`函数从缓冲读取部分数据，因此，缓冲并不总是满的。但如果`read`函数读取速度比接收数据的速度慢，则缓冲有可能被填满。此时套接字无法再接收数据，但即使这样也不会发生数据丢失，因为传输端套接字将停止传输。也就是说，面向连接的套接字会根据接收端的状态传输数据，如果传输出错还会提供重传服务。因此，***面向连接的套接字除了特殊情况外不会发生数据丢失。***

#### 面向信息的套接字——`SOCK_DGRAM`

> 不可靠的、不按序传递的、以数据的高速传输为目的的套接字

面向信息的套接字特点：

+ 强调快速传输而非传输顺序
+ 传输的数据可能丢失也可能损毁
+ 传输的数据有边界
+ 限制每次传输的数据大小

我们采用寄快递来类比：

+ 送往同一目的地的包裹无须保证顺序，只需要最快速度交给客户即可
+ 包裹有丢失或者损坏的风险，并且包裹有大小限制
+ 如果分两次发送，那么接收者也必须分两次接收

***面向消息的套接字比面向连接的套接字具有更快的传输速度，但无法避免数据丢失或者损毁。另外，每次传输的数据大小具有限制，并存在数据边界。数据边界的存在意味着接收数据的次数应和传输次数相同。***

### 协议的最终选择

下面是`socket`函数的第三个参数，该参数决定最终采用的协议。这会引起一定的困惑：前面已经通过两个参数传递了协议族信息和套接字数据传输方式，这些信息还不足以决定采用的协议吗？

答案是，通常情况下，只需要前面两个参数就可以创建所需要的套接字，所以大多数情况下我们向第三个参数传递0。除非遇到这样的情况：

> ###### ***同一协议族中存在多个数据传输方式相同的协议***

数据传输方式相同，但协议不同。此时需要第三个参数具体指定协议信息。

而对于本书基于的IPv4协议来说，使用`SOCK_STREAM`的协议只有`IPPROTO_TCP`，因此我们可以如下方式创建套接字，这种套接字称为***TCP套接字***：

```c
int tcp_socket = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);
```

而对于***“IPv4协议族中面向信息的套接字”***这一要求来说，满足的只有`IPPROTO_UDP`。因此，可以如此调用`socket`函数，这种套接字称为***UDP套接字***：

```c
int udp_socket = socket(PF_INET, SOCK_DGRAM, IPPOTO_UDP);
```
## 面向连接的套接字：TCP示例

本处使用的代码和之前的[hello_server](../示例代码/hello_server.c)以及[hello_client](../示例代码/hello_client.c)相比并无太多变化：

+ `hello_server.c` -> `tcp_server.c`：无变化
+ `hello_client.c` -> `tcp_client.c`：更改`read`函数调用方式

本处主要是要验证TCP套接字的如下特性：***传输的数据不存在数据边界***。

***[tcp_client.c](../示例代码/tcp_client.c)***

```c
#include <netinet/in.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/_endian.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>

void error_handling(char* message);

int main(int argc, char* argv[])
{
	int sock;
	struct sockaddr_in serv_addr;
	char message[30];
	int str_len = 0;
	int idx = 0, read_len = 0;

	if (argc != 3)
	{
		printf("Usage : %s <IP> <port>\n", argv[0]);
		exit(1);
	}

	// 创建TCP套接字。如果前两个参数像这样传递，那么就可以省略第三个参数
	sock = socket(PF_INET, SOCK_STREAM, 0);
	if (sock == -1)
	{
		error_handling("socket() error");
	}

	memset(&serv_addr, 0, sizeof(serv_addr));
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = inet_addr(argv[1]);
	serv_addr.sin_port = htons(atoi(argv[2]));

	if (connect(sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) == -1)
	{
		error_handling("connect() error");
	}

	// tcp_client.c 中新的内容
	// 每次读取1字节
	while ((read_len = read(sock, &message[idx++], 1)) != 0)
	{
		if (read_len == -1)
		{
			error_handling("read() error");
		}

		// read_len的值始终为1
		str_len += read_len;
	}

	printf("Message from server : %s \n", message);
	printf("Function read call count: %d \n", str_len);
	close(sock);
	return 0;
}

void error_handling(char* message)
{
	fputs(message, stderr);
	fputc('\n', stderr);
	exit(1);
}
```

# Windows平台下的验证
