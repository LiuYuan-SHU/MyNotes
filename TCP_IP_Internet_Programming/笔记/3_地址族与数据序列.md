# 地址信息的表示

## 表示IPv4地址的结构体

填写地址信息的思路：

+ 基于哪一种地址族？
+ IP地址是多少？
+ 端口号是多少？

将结构体定义为如下形态就能回答上述提问：

```c
struct sockaddr_in	
{
	sa_family_in	sin_family;		// 地址族（Address Family）
	uint16_t		sin_port;		// 16位TCP/UDP端口号
	struct in_addr	sin_addr;		// 32位IP地址
	char			sin_zero[8];	// 不使用
};

struct in_addr
{
	in_addr_t		s_addr;			// 32位IPv4地址
};
```

首先我们需要了解一些数据类型。`uint16_t`、`in_arr_t`等类型可以参考POSIX（Protable Operating System Interface, 可移植操作系统接口）。POSIX是为UNIX系列操作系统设立的标准，它定义了一些其他数据类型，如下所示：

| 数据类型名称 | 数据类型说明 | 声明的头文件 |
|:--:|:--:|:--:|
| `int8_t` | signed 8-bit int | |
| `uint8_t` | unsigned 8-bit int (unsigned char) | |
| `int16_t` | signed 16-bit int | sys/types.h |
| `uint16_t` | unsigned 16-bit int(unsigned short) | |
| `int32_t` | signed 32-bit int | |
| `uint32_t` | unsigned 32-bit int(unsigned long) | |
| `sa_family_t` | 地址族（address family） | sys/socket.h |
| `socklen_t` | 长度（length of struct） | sys/socket.h |
| `in_addr_t` | IP地址，声明为`uint32_t` | netinet/in.h |
| `in_port_t` | 端口号，声明为`uint32_t` | netinet/in.h |

## 结构体`sockaddr_in`的成员分析

### 成员`sin_family`

每种协议族适用的地址族均不同。比如，IPv4使用4字节地址族，Ipv6使用16字节地址族。

| 地址族（Address Family） | 含义 |
|:--:|:--:|
| AF_INET | IPv4网络协议中使用的地址族 |
| AF_INET6 | IPv6网络协议中使用的地址族 |
| AF_LOCAL | 本地通信中采用的UNIX协议的地址族 |

AF_LOCAL只是为了说明具有多种地址族而添加的。

### 成员`sin_port`

该成员保存16位端口号，重点在于，它以网络字节序保存

### 成员`sin_addr`

该成员保存32位IP信息，且也以网络字节序保存。为理解好该成员，应同时观察结构体`in_addr`。但结构体`in_addr`声明为`uint32_t`，因此只需当作32位整数型即可。

### 成员`sin_zero`

***无特殊含义，只是为了使结构体`sockaddr_in`的大小与`sockaddr`结构保持一致而插入的成员。必需填充为0，否则无法得到想要的结果。***

之所以我们要这样做，需要参考`bind`函数的接口：

```c
int bind(int socket, const struct sockaddr *address, socklen_t address_len);
```

我们之所以要这样设计，就是为了能够在`bind`函数中兼容`sockaddr_in`;

```c
struct sockaddr
{
	sa_family_t	sin_family;		// 地址族（Address Family）
	char		sa_data[14];	// 地址信息
};
```

此结构体要求成员`sa_data`保存的地址信息中需包含IP地址和端口号，剩余部分应填充0，这也是`bind`函数要求的。而这对于包含地址信息来讲非常麻烦，继而就有了新的结构体`sockaddr_in`。

# 网络字节序与地址变换

不同CPU中，数据在内存空间的保存方式是不同的。有些CPU以顺序存储，有些CPU以逆序存储。如果不考虑这些就收发数据则会发生问题，因为保存顺序的不同意味着对接收数据的解析顺序也不同。

## 字节序（Order）与网络字节序

CPU向内存保存数据的方式有2种，这意味着CPU解析数据的方式也分2种：

* 大端序（Big Endian）：高位字节放到低位地址
* 小端序（Little Endian）：高位字节存放到高位地址

正因如此，在通过网络传输数据时约定同一方式，这种约定称为网络字节序（Network Byte Order），非常简单——***统一为大端序***

即，先把数据数组转化成大端序格式再进行网络传输。因此，所有计算机接收数据时应识别该数据时网络字节序格式，小端序系统传输数据时应转化为大端序排列方式。

## 字节序转换

接下来介绍帮助转换字节序的函数

+ `unsigned short htons(unsigned short)`
+ `unsigned short ntohs(unsigned short)`
+ `unsigned long htonl(unsigned long)`
+ `unsigned long ntohl(unsigned long)`

通过函数名应该能掌握其功能，只需了解以下细节：

+ `htons`中的h代表主机（host）字节序
+ `htons`中的h代表网络（network）字节序

另外，s指的是short，l指的是long（Linux操作系统中`long`占4个字节，这很关键）。因此，`htons`可以解释为：“把`short`型数据从主机字节序转化为网络字节序”

通常，以s作为后缀的函数中，s代表2个字节`short`，因此用于端口转换；以l作为后缀的函数中，l代表4个字节，所以用于IP转换

另外，不能因为本地机时大端序的，就跳过转换函数。意即，***即使在大端序系统中，最好也经过主机字节序转换为网络字节序的过程。***当然，此时主机字节序与网络字节序相同，不会有任何变化。

***[endian_conv.c](../示例代码/endian_conv.c)***

```c
#include <stdio.h>
#include <arpa/inet.h>

int main(int argc, char* argv[])
{
	unsigned short host_port = 0x1234;
	unsigned short net_port;
	unsigned long host_addr = 0x12345678;
	unsigned long net_addr;

	net_port = htons(host_port);
	net_addr = htonl(host_addr);

	printf("Host ordered port: %#x \n", host_port);
	printf("Network ordered port: %#x \n", net_port);
	printf("Host ordered address: %#lx \n", host_addr);
	printf("Network ordered address: %#lx \n", net_addr);

	return 0;
}
```

输出结果：

```
Host ordered port: 0x1234
Network ordered port: 0x3412
Host ordered address: 0x12345678
Network ordered address: 0x78563412
```

这就是在小端序CPU中运行的结果。如果在大端序CPU中运行，则变量值不会改变。大部分的运行结果都会是这个样子，因为Intel和AMD系列的CPU都采用小端序标准。

> ***数据在传输之前都要经过转换吗？***
>
> 如果数据收发过程中没有自动转换机制，那就需要程序员手动转换。这光想想就让人害怕。实际上没有必要，这个过程是自动的。除了向`sockaddr_in`结构体变量填充数据外，其他情况无须考虑字节序问题。

# 网络地址的初始化与分配

## 字符串信息与网络字节序的整数型之间的转化

### 将字符串信息转化成网络字节序的整数型 —— `inet_addr`

`sockaddr_in`中保存地址信息的成员为32位整数型。因此，为了分配IP地址，需要将其表示为32位整数型数据。这对于只熟悉字符串信息的我们来说实非易事。

### 

对于IP地址的表示，我们熟悉的事点分十进制表示法（Dotted Decimal Notation），而非整数型数据表示法。幸运的是，有个函数可以帮我们讲字符串形式的IP地址转换成32位整数型数据。***此函数在转换类型的同时也会进行网络字节序转换。***

```c
#include <arpa/inet.h>

// 成功时返回32位大端序整数型数值，失败时返回INADDR_NONE
int_addr_t inet_addr(const char* string);
```

如果向该函数传递类似“211.214.107.99”的点分十进制格式的字符串，它会将其转换为32位整数型数据并返回。当然，该整数值满足网络字节序。另外，该函数的返回类型`int_addr_t`在内部声明为32位整数型。

***[inet_addr.c](../示例代码/inet_addr.c)***

```c
#include <stdio.h>
#include <arpa/inet.h>

int main(int argc, char* argv[])
{
	char *addr1 = "1.2.3.4";
	char *addr2 = "1.2.3.256";	// 一个字节能表示的最大值是255，也就是说这是个无效地址

	unsigned long conv_addr = inet_addr(addr1);
	if (conv_addr == INADDR_NONE)
	{
		printf("Error occured!");
	}
	else
	{
		printf("Network ordered integer addr: %#lx \n", conv_addr);
	}

	conv_addr = inet_addr(addr2);
	if (conv_addr == INADDR_NONE)
	{
		printf("Error occured!");
	}
	else
	{
		printf("Network ordered integer addr: %#lx \n", conv_addr);
	}

	return 0;
}
```

运行结果：

```
Network ordered integer addr: 0x4030201
Error occured!
```

可以看到，`inet_addr`函数不仅可以把IP地址转换成32整数型，而且可以检测无效的IP地址。另外，从输出结果可以验证确实转换为网络字节序。

### 将字符串信息转化成网络字节序的整数型，并填入`in_addr`结构体 —— `inet_aton`

`inet_aton`函数与`inet_addr`函数在功能上完全相同，也将字符串形式IP地址转换为32位网络字节序并返回。只不过该函数利用了`in_addr`结构体，且其使用频率更高。

```c
#include <arpa/inet.h>

// 成功时返回1（true），失败时返回false（0）
/*
 * string：含有需转换的IP地址信息的字符串地址值
 * addr：将保存转换结果的in_addr结构体变脸的地址值
 */
int inet_aton(const char* string, struct in_addr* addr);
```

实际编程中若要调用`inet_addr`函数，需将转换后的IP地址信息代入`sockaddr_in`结构体中声明的`in_addr`结构体变量。而`inet_aton`函数则不需要此过程，因为函数会自动将结果填入。

***[inet_aton.c](../示例代码/inet_aton.c)***

```c
#include <stdio.h>
#include <stdlib.h>
#include <arpa/inet.h>

void error_handling(char* message);

int main()
{
	char *addr = "127.232.124.79";
	struct sockaddr_in addr_inet;

	if (!inet_aton(addr, &addr_inet.sin_addr))
	{
		error_handling("Conversion error");
	}
	else
	{
		printf("Network ordered integer addr : %#x \n", addr_inet.sin_addr.s_addr);
	}

	return 0;
}

void error_handling(char* message)
{
	fputs(message, stderr);
	fputc('\n', stderr);
	exit(1);
}
```

### 将网络字节序的整数型转化为字符串 —— `inet_ntoa`

```c
#include <arpa/inet.h>

// 成功时返回转换的字符串地址值，失败时返回-1
char* inet_ntoa(struct in_addr adr);
```

调用该函数的时候需要十分小心，因为返回类型是`char *`。返回字符串地址意味着字符串已经保存到内存空间，但该函数未向程序员要求分配内存，而是在内部申请了内存并保存了字符串。也就是说，调用完该函数之后，应该立即将字符串信息复制到其他内存空间。因为，若再次调用`inet_ntoa`函数，则有可能覆盖之前保存的字符串信息。总之，再次调用`inet_ntoa`函数前返回的字符串地址是有效的。若要长期保存，则应该将字符串复制到其他内存空间。

```c
#include <stdio.h>
#include <string.h>
#include <arpa/inet.h>

int main()
{
	struct sockaddr_in addr1, addr2;
	char *str_ptr;
	char str_arr[20];

	addr1.sin_addr.s_addr = htonl(0x1020304);
	addr2.sin_addr.s_addr = htonl(0x1010101);

	str_ptr = inet_ntoa(addr1.sin_addr);
	strcpy(str_arr, str_ptr);
	printf("Dotted-Decimal notation1: %s \n", str_ptr);

	// 此处我们直接运行inet_ntoa，而不去更新str_ptr
	// 但是str_ptr指向的地址中的内容其实已经被更新了
	inet_ntoa(addr2.sin_addr);
	printf("Dotted-Decimal notation2: %s \n", str_ptr);
	printf("Dotted-Decimal notation3: %s \n", str_arr);

	return 0;
}
```

运行结果：

```
Dotted-Decimal notation1: 1.2.3.4
Dotted-Decimal notation2: 1.1.1.1
Dotted-Decimal notation3: 1.2.3.4
```

## 网络地址初始化

现在介绍套接字创建过程中常见的网络地址信息初始化方法：

### 服务端地址信息初始化

```c
struct sockaddr_in addr;					// 声明IP地址字符串
char* serv_ip = "211.217.16	8.13";			// 声明IP地址字符串
char* serv_port = "9190";					// 声明端口号字符串
memset(&addr, 0, sizeof(add	r));			// 结构体变量addr的所有成员初始化为0
addr.sin_family = AF_INET;					// 指定地址族
addr.sin_addr.s_addr = inet_addr(serv_ip);	// 基于字符串的IP地址初始化
addr.sin_port = htons(atoi(serv_port));		// 基于字符串的端口号初始化
```

上述代码中，`memset`将每个字节初始化为0；这么做是为了将`sockaddr_in`结构体的成员`sin_zero`初始化为0。另外，最后一行代码调用的`aot`函数将字符串类型的值转换为整数型。总之，上述代码利用字符串格式的IP地址和端口号初始化了`sockaddr_in`结构体变量。

另外，代码中对IP和端口号进行了硬编码，这不是一个好习惯，因为运行环境改变就得更改代码。因此，我们应该在运行程序的时候传入IP地址和端口号。

### 客户端地址信息初始化

上述代码主要用于服务端，给套接字分配IP地址和端口号主要是为了方便操作系统把从特定网卡和端口传入的数据交给自己。

反观客户端，其只需要知道想要访问的IP和端口就好了。

请求方法不同意味着调用的函数不同。服务器端的准备工作通过`bind`函数完成，而客户端则通过`connect`函数完成。因此，函数调用前需准备的地址值类型也不同。

+ 服务端声明`sockaddr_in`结构体变量，将其初始化为赋予服务器端IP和套接字的端口号，然后调用`bind`函数
+ 而客户端则声明`sockaddr_in`结构体，并初始化为要预制链接的服务器端套接字的IP和端口号，然后调用`connect`函数

## INADDR_ANY

每次创建服务器套接字都要输入IP地址会有些繁琐，此时可以使用INADDR_ANY初始化`addr.sin_addr.s_addr`：

```c
addr.sin_addr.s_addr = htonl(INADDR_ANY);
```

与之前方式的最大区别在于，利用常数`INADDR_ANY`分配服务器端的IP地址。若采用这种方式，则可自动获取运行的服务器端的计算机IP地址，不必亲自输入。而且，若同意计算机中已经分配多个IP地址（多宿主（Multi-homed）计算机，一般属于路由器一类），则只要端口号一致，就可以从不同IP地址接收数据。因此，服务器中优先考虑这种方式。而客户端中除非带有一部分服务器端功能，否则不会采用。

> ###### 创建服务器端套接字时需要IP地址的原因
>
> 初始化服务器端套接字时应分配所述计算机的IP地址，因为初始化时使用的IP地址非常明确，那为何还需要进行IP分配呢？
>
> 如前所述，同一台计算机中可以分配多个IP地址，实际IP地址的个数与计算机中安装的NIC数量相等。即使是服务器端套接字，也需要决定应接收哪个IP传来的（哪个NIC传来的）数据。因此，服务器端套接字初始化过程中要求IP地址信息。
>
> 另外，若只有一个NIC，则直接使用INADDR_ANY

### 第一章的[`hello_server.c`](../示例代码/hello_server.c)、[`hello_client.c`](../示例代码/hello_client.c)运行过程

第一章中执行以下命令相当于运行服务器端的`hello_server.c`：

```shell
./hello_server 5005
```

通过代码可知，向`main`函数传递的5005为端口号。通过此端口创建服务器端套接字并运行程序，但未传递IP地址，因为可以通过INADDR_ANY指定地址。

执行以下命令相当于运行客户端的`hello_client.c`

```shell
./hello_client 127.0.0.1 5005
```

127.0.0.1是回送地址（loopback address），指的是计算机自身IP地址。当然，若用实际IP地址代替此地址也能正常运转。

## 向套接字分配网络地址

既然已经讨论了`sockaddr_in`结构体的初始化方法，接下来就把初始化信息的地址信息分配给套接字。`bind`函数负责这项操作：

```c
#include <sys/socket.h>

// 成功时返回0，失败时返回-1
/*
 * sockfd：要分配地址信息（IP地址和端口号）的套接字文件描述符
 * myaddr：存有地址信息的结构体变量地址值
 * addrlen：第二个结构体变量的长度
 */
int bind(int sockfd, struct sockaddr_in* myaddr, socklen_t address_len);
```

下面给出服务器端常见套接字初始化过程：

```c
int serv_sock;
struct sockaddr_in serv_addr;
char* serv_port = "5005";

// 创建服务器端套接字（监听套接字）
serv_sock = socket(PF_INET, SOCK_STREAM, 0);

// 地址信息初始化
memset(&serv_addr, 0, sizeof(serv_addr));
serv_addr.sin_family = AF_INET;
serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);
serv_addr.sin_port = htons(atoi(serv_port));

// 分配地址信息
bind(serv_sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr));

// .....
```

服务器端默认代码如上，当然还有未显示的异常处理代码。

# 基于Windows实现
